<!DOCTYPE html>
<meta charset=utf-8>
<title>Strings - Dive Into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 4}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#strings>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>Difficulty level: <span class=u title=intermediate>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Strings</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> I&#8217;m telling you this &#8217;cause you&#8217;re one of my friends.<br>
My alphabet starts where your alphabet ends! <span class=u>&#x275E;</span><br>&mdash; Dr. Seuss, On Beyond Zebra!
</blockquote>
<p id=toc>&nbsp;

<h2 id=boring-stuff>약간 지루하지만, 반드시 짚고 넘어가야 할 사실들</h2>


<p class=f>많은 사람들이 무심코 지나치는 사실이지만, 사실 문자 체계란 놀랄 정도로 복잡한 것 중 하나입니다. 알파벳을 예로 들어봅시다. <a href=http://en.wikipedia.org/wiki/Bougainville_Province>Bougainville</a>이라는 나라가 있습니다. 세상에서 가장 적은 수의 알파벳을 가지고 있는 나라이고요. <a href=http://en.wikipedia.org/wiki/Rotokas_alphabet>Rotokas alphabet</a> 이라는 알파벳을 가지고 있는데, 단지 12개의 문자, 즉 A, E, G, I, K, O, P, R, S, T, U, V 만을 가지고 있습니다. 한편, 이와는 반대로, 중국어나 일본어, 한국어 같은 언어는 수 천여개의, 알파벳에 해당하는 문자들을 가지고 있습니다. 영어는 26개의 문자 &nbsp;&mdash;&nbsp;대소문자를 별도로 구별한다면 52개&nbsp;&mdash;&nbsp;와 <i class=baa>!@#$%&amp;</i> 같은 약간의 특수문자들도 가지고 있습니다.

<p>여러분은 &#8220;텍스트&#8221;라고 하면 컴퓨터 스크린 위 문자나 기호를 떠올릴지도 모르겠습니다. 컴퓨터는 사실 문자나 기호를 직접 다루지 못합니다. 대신 비트나 바이트를 다룰 수 있지요. 여러분이 컴퓨터 스크린 위에서 보는 텍스트란 사실 특정 <i>문자열 인코딩</i>에 의해 저장된 비트나 바이트인 셈입니다. 
결국 문자열 인코딩이란 여러분이 스크린을 통해 보는 어떤 텍스트 기호와 실제로 그 내부에 저장된 비트간의 연결고리인 셈 입니다. 이런 문자열 인코딩의 종류는 아주 다양합니다. 러시안어나 중국어, 영어와 같이 특정 언어 만 지원하는 것에서부터, 여러 가지의 언어들을 한꺼번에 처리할 수 있는 것들도 있습니다.  

<p>문자열 인코딩의 세계는 사실 좀 전에 말씀드린 것보다 조금 더 복잡합니다. 어떤 문자들은 서로 다른 여러 개의 인코딩을 사용하더라도 화면상으론 동일하게 표현되지만, 실제 각각의 인코딩 내부는 서로 다른 바이트 배열을 사용하고 있기도 합니다. 문자열 인코딩은 암호를 푸는 열쇠정도로 생각하셔도 됩니다. 직장상사가 여러분에게 바이트 배열을 휙하고 던져주고 나서, &#8220;자. 잘들으세요. 이건 파일이구요, 요건 웹 페이지입니다. 아. 참! 그리고 이거 전부 다 텍스트 데이타예요.&#8221;이렇게 말하고 쌩하니 가버렸다고 생각해봅시다. 황당한 기분에 던져진 바이트 배열을 들여다 보지만, 손에 쥔 것은  0과 1로 이루어진 바이트 더미일 뿐입니다. 이걸 텍스트로 올바르게 해석해내기 위해서는 캐릭터 인코딩이 뭘로 되있었는지 물어봤어야 했습니다. 지금이라도 물어보러 가야겠군요. 하지만, 만약 상사가 잘못된 정보를 알려주었거나, 아예 모르쇠로 일관하는 경우엔 십중팔구 여러분은 오후 내내 이게 뭔지 골머리싸고 끙끙대다가 두 손 두 발 다들고, 포장마차에서 소주잔이나 기울이며 신세한탄을 할 수 밖에 없을 겁니다.


<aside>여러분이 문자열에 대해 알고 있던 것들은 전부 잘못된 겁니다.</aside>

<p>따옴표가 나와야 할 자리에 요상하게 생긴 물음표가 나오는 웹페이지를 본 적이 있나요? 아니면 웩켁쵁 처럼 희한한 문자로 가득한 웹페이지는요? 이는 모두 웹 페이지 작성자가 문자열 인코딩 설정을 제대로 해주지 않아서 생기는 일입니다. 아무리 날래고 쌩쌩한 웹 브라우저라도 이런 대책없는 페이지를 만나게 되면, 그야말로 어찌할바를 모르다가 종국에는 이런 알 수 없는 요상한 기호들을 쏟아내게 되는 거죠. 

<p>세상 대부분의 주요언어들은 컴퓨터에서 적절히 처리되기 위한 고유한 문자열 인코딩 방식을 가지고 있습니다. 모든 나라의 문자가 서로 다르고, 이를 한꺼번에 처리한다는 것은 컴퓨터에겐 힘들고 값비싼 작업이었으므로, 각 나라의 문자열 인코딩방식은 그 나라의 언어에 최적화되어 있었습니다. 제가 여기서 말하는 그나라 언어에 최적화 되있다는 말은 서로 다른 인코딩 방식이라도 0&ndash;255 범위 내에 있는 같은 숫자를 사용할 수 있고, 같은 숫자지만 표시하는 문자는 언어별로 다르다는 겁니다. 가령 , 예를 들어, <abbr>ASCII</abbr> 라는 인코딩 방식에 대해 들어본 적이 있을겁니다. 0 부터 127 사이에 값에 영어 알파벳을 매칭해놓은 인코딩 방식으로, 여기서 65라는 숫자는 &#8220;A&#8221;이고, 97은 소문자 &#8220;a&#8221 입니다. 영어는 아주 작은 수의 알파벳 집합을 가지고 있을 뿐이므로, 128개로 모든 문자를 표현할 수 있습니다.  128개는 2의 7승이므로, 한 바이트 (2의 8승)로 알파벳을 모두 표현할 수 있는 셈입니다. 

<p>프랑스어나 스페인어, 독일어 같은 동유럽권의 언어는 영어보다 많은 수의 알파벳을 가지고 있습니다. 좀더 정확히 말하면, 이들 언어에는 알파벳 위에 물결 표시와 같은 (틸다라고 부른답니다) 것을 얹어놓은 듯한, 가령 <code>&ntilde;</code> 와 같은 문자도 있습니다. 이 언어들을 위한 대표적인 인코딩방식이 CP-1252 입니다. &#8220;windows-1252&#8221; 이라고도 불리는데 Microsoft Windows에서 많이 사용되었기 때문입니다. CP-1252 의 0부터 127까지의 값은 <abbr>ASCII</abbr> 코드의 값과 동일합니다. 그리고 128 부터 255 까지의 범위의 값에는 앞에서 예를 들었던 <code>&ntilde;</code> 같은 문자들 할당해두었습니다. 예를 들어, <code>&ntilde;</code>는 241입니다. 영어에 사용되는 ascii 방식보다는 데이터가 많이 필요하지만, 그래도 여전히 한 바이트 (0-255)만 있으면 모든 문자를 표현할 수 있습니다.

<p>한편 중국어, 일본어, 한국어 같은 언어들이 있습니다. 이 언어들은 영어의 알파벳에 해당하는 문자가 수천개에 달하므로 한 바이트 만으로는 해결할 수 없습니다. 따라서 이런 나라의 언어들을 위해서는 한 바이트가 더 필요하여 총 두 바이트를 사용해야 합니다(0&ndash;65535). 제가 앞서 드린 말씀 중에 한 바이트 인코딩에서는 각 언어에 최적화 되어 있다고 한 것 기억나시나요? 같은 숫자를 사용하지만, 표현되는 문자는 언어별로 다르다는 거요. 이 사실은 두 바이트 문자열 인코딩에서도 그대로 적용됩니다. 표현해야 하는 문자의 숫자가 증가한 것 밖에는 차이나는 것이 없습니다.

<p>사실 이런 문제는 여러분이 직접 &#8220;텍스트&#8221;를 입력하고 출력하는 한 문제될 것은 없었습니다. &#8220;평범한 텍스트 (plain text)&#8221;라는 개념은 존재하지도 않았습니다. 프로그램 소스코드는 <abbr>ASCII</abbr> 코드로 되어있고, 워드프로세서를 사용하는 사람들도 평범한 텍스트건, 워드프로세서에서 정의한 기호이던 간에, 동일한 소프트웨어만 사용한다면, 입력하고 출력하는데 아무런 문제가 없었던 것입니다.

<p>하지만 이제, 워드프로세서 앞에서 문서나 작성하던 시대는 지났고, 이메일이나 웹 서핑같은 일이 일상이 되어버린 글로벌 네트워크의 시대가 되었습니다. 엄청난 양의 &#8220;평범한 텍스트 (plain text)&#8221;들이 전세계를 휘저으며 돌아다니고 있습니다. 여러분의 PC에서 작성된 이메일이 어떤 컴퓨터를 거쳐 또 다른 컴퓨터에게로 전송됩니다. 반면 컴퓨터는 글을 읽을 수 없습니다. 단지 숫자만을 처리하지요. 앞에서 이야기한 것처럼 같은 숫자라도 맥락에 따라 (어떤 문자열 인코딩을 사용했느냐에 따라) 다른 의미를 가질 수 있습니다. 명심하세요. 보낸 사람이 타이핑했던 대로 받는 사람이 읽기 위해서는, 컴퓨터가 다루는 숫자를 사람이 읽을 수 있는 글자로 변환할 수 있는 어떤 변환 키 같은 것이 필요합니다. 이 키가 없는 당신은 화면에 온통 이상하게 뭉그러지고, 찌그러진 기호더미 앞에서 한숨을 쉴 수 밖에 없습니다. 

<p>한편으로, 여러 종류의 텍스트를 한 군데 모아놓고 처리해야 하는 상황에 대해 생각해봅시다. 예를 들어, 여러분들이 받은 이메일을 어떤 데이터베이스에 저장해두는 상황이 있을 수 있겠죠? 텍스트만 저장해두면 될까요? 아니죠. 텍스트를 적절하게 화면에 표시하기 위해서는 어떤 문자열 인코딩을 사용했는지도 함께 저장해야 합니다. 흠. 얼핏봐도 쉽지 않을 거 같군요. 이메일이 있는 데이터베이스를 검색해야 하는 상황은 또 어떤가요? 이 때는 해당 검색 키워드에 맞는 문자열 인코딩으로 그때 그때 변경해줘야 제대로 된 검색 결과를 얻을 수 있을 것 같군요. 음. 역시 만만치 않을 거 같네요.

<p>여러분이 작성중인 문서에 영어와 한국어를 동시에 사용해야 하는 경우도 생각해봅시다. (힌트입니다: 실제로 이런 워드프로세스 어플리케이션들은 특정 문자열 인코딩 모드에서 다른 문자열 인코딩 모드로 변경할 때 마다 escape code 를 사용합니다. 여러분 PC의 인코딩 모드가 러시안 koi8-r에 있는 경우 숫자 241은 Я 를 의미합니다만, Mac Greek 모드로 변경되는 순간 이 숫자는  ώ를 의미합니다.) 당연히 이 문서도 특정 텍스트로 검색할 수 있어야 합니다.


<p>짜증이 쓰나미처럼 밀려오시나요? 자, 자. 일단 좀 진정하시고요, 여기까지 읽으신 분들은 미리 잠시 머리를 식혀두시기 바랍니다. 왜냐면 이제까지 여러분이 알고 있던 문자열에 대한 지식은 모두 잘못된 것이라는 사실에 분노게이지가 하늘을 찌를 수도 있으니까요. 아무튼 중요한건, plain text 따위는 이제부턴 존재하지 않는다는 겁니다. 오늘부터 이렇게 딱 정한거예요. 자 이제 본격적으로 들어갑니다. 심호흡하시고, 안전벨트 매세요.



<p class=a>&#x2042;

<h2 id=one-ring-to-rule-them-all>Unicode</h2>

<p><i>Enter <dfn>Unicode</dfn>.</i>


<p>유니코드 (Unicode)란 지구상의 모든 언어를 표현하기 위해 고안된 문자 인코딩 시스템입니다. 지구상의 모든 기호와 문자들을 4 바이트 범위내의 숫자로 표현합니다. 각 숫자는 각각 고유한 문자를 표현하므로 절대 겹치는 일은 없습니다만, 만약 특정 문자가 여러 개의 언어에서 사용되는 경우엔 (영어 알파벳을 공통으로 사용하는 나라가 생각보다 많습니다.) 해당하는 유니코드 숫자는 동일한 숫자를 사용합니다. 아무튼 여기서 중요한 내용은 특정 유니코드 숫자는 고유한 문자 하나를 의미한다는 것 입니다. 예를 들어 유니코드의 숫자 <code>U+0041</code> 는 언제나 <code>'A'</code> 라는 문자를 의미하는 거죠. 


<p>자, 이제 우리의 문제가 완벽하게 해결된 것 같지 않나요? 이제 한 문서에 여러 종류의 문자로 입력할 수도 있고, 더 이상 인코딩 모드를 변경시키면서 이 모드에서 저 모드로  번거롭게 왔다 갔다 하지 않아도 되겠네요. 하지만 혹시 그런 생각 안드세요? "뭐? 4 바이트나 사용한다고 ?!! 이거 너무 낭비가 심하잖아 !!" 특히 영어권에서 온 성질급한 사람들은 더할겁니다. 고작 24개 밖에 안되는 알파벳을 사용하는데 4 바이트라니요. 4 바이트면 자그마치 40억개가 넘는 가짓수를 표현할 수 있는 크기입니다. 사실 영어권의 사람들은 한 바이트만 있어도 충분하죠. 한 바이트로도 256 가짓수의 서로 다른 문자를 표현할 수 있으니까요. 심지어 어마어마한 종류의 문자를 가지고 있는 중국어도 두 바이트만 있으면 거뜬히 표현할 수 있거든요. 
 
<p>아무튼 이렇게 한 문자를 4바이트로 표현하는 유니코드 인코딩 방식을 UTF-32 방식이라고 합니다. 뒤에 붙은 숫자 32는 4바이트가 32비트이기 때문에 그렇게 정한 것입니다. UTF-32는 가장 직관적인 인코딩 방식입니다. 세계 어느나라의 문자도 4 바이트에 해당하는 숫자로 고유하게 맵핑되기 때문에, 특정 유니코드 문자를 검색해야하는 경우 그 숫자만큼 이동하면 됩니다. 따라서 어떤 문자건 간에 정해진 시간 내에 찾아낼 수 있습니다. 하지만 그 대신, 앞에 언급한대로, 32 비트라는 커다란 공간을 할당해야 하는 맹점도 함께 가지고 있습니다. 

<p>유니코드 안에 어마어마한 양의 문자들이 있긴 하지만, 사람들은 곧 유니코드의 뒷 쪽에 배치되있는 특수기호나 문자는 거의 사용할 일이 없다는 사실을 깨닫게 됩니다. 그리고 나서 UTF-16 이라는 새로운 인코딩 표준이 짜잔하고 등장하게 됩니다. 짐작하시듯 이 기술은 16 비트, 즉 2 바이트의 숫자만 사용하는 것으로, 표현할 수 있는 범위는 0 - 65535 까지 입니다. 이 범위를 넘어서는 문자를 표현해야 하는 경우엔 조금 지저분한 꼼수를 사용하긴 합니다만, 어쨋건 표현이 가능합니다. UTF-16이 UTF-32에 비해 갖는 이점은 명확합니다. UTF-32에 비해 할당해야 할 바이트 크기를 반으로 줄일 수 있고, 여전히 검색성능도 나쁘지 않습니다. (검색해야 하는 문자가 0 부터 65535 범위내라면 말이죠.)

<p>그러나, UTF-32에도 UTF-16에도 뭔가 뒷맛이 개운치 못한 문제가 있었으니, 그것은 바로 바이트를 저장하는 방식인 Byte Order가 컴퓨터마다 다르다는 것이었습니다. 가령 예를 들면  UTF-16 문자 <code>U+4E2D</code>의 경우 컴퓨터 OS 가 Big-endian을 사용하느냐, Little-endian을 사용하느냐에 따라 <code>4E 2D</code> 로 저장될 수도 있고, <code>2D 4E</code> 로 저장될 수도 있습니다. (역자주. 인텔 CPU 기반의 윈도우와 리눅스 PC는 리틀 엔디안을 사용하고, RISC 기반의 UNIX 시스템이나 네트워크 시스템은 빅 엔디안을 사용합니다.) UTF-32의 경우엔 사이즈가 커지니만큼 상황이 더 안좋고요. 만약 남들과 문서를 주고받을 일이 없다면 상관 없겠지만, 엔디안 방식이 다른 어딘가에 있는 PC로 전송해야 하는 경우엔 내가 어떤 인코딩 방식을 사용했는지를 알려주어야 받는 쪽에서 올바르게 해석할 수 있을 겁니다.

<p>이런 문제를 해결하기 위해 UTF-32 (4바이트) 나 UTF-16 (2바이트) 같이 멀티 바이트를 사용하는 인코딩 시스템에서는 &#8220;Byte Order Mark,&#8221 라고 하는 특수한 종류의 문자를 만들어 사용합니다. 그리고 이 Byte Order Mark를 전송하는 모든 문서 앞 부분에 포함시켜서 문서에 사용된 Byte Order를 표시합니다. UTF-16 시스템의 Byte Order Mark는 <code>U+FEFF</code> 입니다. 만약 여러분이 어딘가로부터 받은 UTF-16 문서가 <code>FF FE</code> 로 시작한다면 동일한 바이트 순서를 사용하는 것이고, <code>FE FF</code> 로 시작한다면 바이트 순서가 바뀌었다는 의미입니다. 

<p>하지만 UTF-16 이 이상적인 것은 아닙니다. 특히 <abbr>ASCII</abbr> 문자를 많이 다루어야 하는 상황이라면 말이죠. 중국에 있는 어느 회사의 웹사이트를 생각해봅시다. 만약 이 웹사이트가 영자신문과 같이 대부분의 정보는 영어로 이루어져 있고, 가끔씩 중국어가 나오는 상황이라면 어떨까요? 음. 대부분의 영어정보는 ASCII 문자로 표현 할 수 있고, 중국어의 경우라도 두 바이트로 너끈히 해결이 가능하겠군요. 검색도 정해진 시간에 가능할거구요. 하지만 두 바이트 범위를 넘어서는 문자에 대해서는 어떻게 해야할까요. 별도로 참조테이블을 운영하지 않는 이상 이 문제는 속시원히 해결되지 않을겁니다.

<p>실망하지 마세요. 여기, 해결책이 있습니다.


<p class=xxxl>UTF-8


<p>UTF-8 은 유니코드를 위한 <em>가변길이(variable-length)</em> 인코딩 시스템입니다. 즉, 고정된 크기의 바이트를 이용하는게 아니라, 문자마다 바이트 길이가 달라질 수 있다는 거죠. <abbr>ASCII</abbr> 코드 (A-Z, <i class=baa>&amp;</i>c.) 의 경우 문자마다 한 바이트만 사용합니다. 사실 UTF-8 인코딩에서 등장하는 1부터 127까지의 바이트 코드와 ASCII 에서 1부터 127 까지의 바이트코드는 동일합니다. 즉 ASCII 코드에서 등장하는 128 종류의 문자는 UTF-8 에서도 동일한 바이트 코드를 갖는다는 거죠. &ntilde; 나 &ouml; 같은 확장 라틴어는 두 바이트를 사용하고, 중국어의 경우는 세 바이트를 사용합니다. 잘 사용되지 않는 &#8220;astral plane (아스트랄 평면)&#8221; 같은 경우엔 4 바이트를 사용합니다.

물론 UTF-8 에도 장점과 단점이 공존합니다.

단점: 각 문자가 각기 다른 바이트 크기일 수 있기 때문에 N 번째의 문자를 검색하는 속도가 O(N)에 가깝습니다. 즉, 어떤 단어 안에서 특정 문자를 검색해야 할때, 그 단어가 길면 길수록 검색하는 시간이 길어집니다. 또한 가변길이의 인코딩 시스템이기 때문에 인코딩이나 디코딩을 할때 비트 오퍼레이션을 사용해야 합니다.

장점:
<abbr>ASCII</abbr> 코드같이 광범위하게 사용되는 문자를 인코딩해야 할때 탁월한 성능을 보여줍니다. 확장 라틴어의 경우엔 UTF-16과 성능이 비슷하고 (두 바이트를 쓰니까요), 중국어의 경우엔 UTF-32 보다 성능이 좋습니다. 그리고 비트 오퍼레이션을 해야 하는 특성상, 멀티 바이트 인코딩 시스템 (UTF-16, UTF-32) 의 경우에서 발생할 수 있는, 바이트 순서로 인해 발생되는 문제도 미연에 방지할 수 있습니다. 즉, <abbr>UTF-8</abbr>로 인코딩된 문서의 경우 어느 컴퓨터에 갖다놓더라도 동일한 바이트 순서를 갖게 됩니다.


<p class=a>&#x2042;

<h2 id=divingin>Diving In</h2>

<p>파이썬 3에서 모든 스트링은 유니코드 문자열입니다. <abbr>UTF-8</abbr> 이나 CP-1251 등으로 인코딩 되어있지 않은 그냥 유니코드일 뿐입니다. UTF-8 같은 인코딩 시스템은 문자열을 바이트배열로 바꿔주는 방법중의 하나라는 사실을 잊지마세요. 만약 어떤 스트링을 특정 인코딩 시스템을 사용하여 해당 바이트 배열로 바꾸고 싶다면, Python 3 를 이용할 수 있습니다. 반대로 특정 바이트 배열을 스트링으로 바꾸고 싶다면 또 역시 Python 3를 이용할 수 있습니다. 바이트 배열은 문자열이 아닙니다. 바이트 배열은 문자 그대로 바이트 배열일 뿐입니다. 문자열은 추상화 단계의 개념이고, 스트링은 이러한 문자열들의 집합입니다.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>s = '深入 Python'</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>len(s)</kbd>               <span class=u>&#x2461;</span></a>
<samp class=pp>9</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[0]</kbd>                 <span class=u>&#x2462;</span></a>
<samp class=pp>'深'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s + ' 3'</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>'深入 Python 3'</samp></pre>

<ol>
<li>파이썬에서 스트링을 생성하려면 간단히 따옴표로 묶어주면 됩니다. 파이썬 문자열은 홑 따옴표(<code>'</code>)나 또는 이중 따옴표(<code>"</code>)를 사용하여 정의할 수 있습니다. <!--"-->
<li>파이썬 내장함수 <code><dfn>len</dfn>()</code> 은 문자열의 길이를 리턴해줍니다. <i>즉,</i> 문자의 갯수를 반환합니다. 이 함수는 <a href=native-datatypes.html#extendinglists>리스트(list)나 튜플(tuple), 셋(set), 딕셔너리(dictionary) 에도 사용</a>할 수 있습니다. 스트링은 문자열의 튜플로 생각할 수 있습니다.
<li>마치 리스트안에서 개별적인 아이템을 꺼내듯, index 표기법을 이용하면 개별 문자를 추출할 수 있습니다.
<li>리스트에서와 같이, <code>+</code> 연산자를 이용하여 string을 다른 string과 <dfn>concatenate</dfn> 할 수도 있습니다.
</ol>

<p class=a>&#x2042;

<h2 id=formatting-strings>Formatting Strings</h2>


<aside>String 을 정의할때는 홑 따옴표나 이중 따옴표를 사용하면 됩니다.</aside>
<p><a href=your-first-python-program.html#divingin><code>humansize.py</code> 코드를 봅시다.</a>:


<p class=d>[<a href=examples/humansize.py>download <code>humansize.py</code></a>]
<pre class=pp><code><a>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],         <span class=u>&#x2460;</span></a>
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}

def approximate_size(size, a_kilobyte_is_1024_bytes=True):
<a>    '''Convert a file size to human-readable form.                          <span class=u>&#x2461;</span></a>

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

<a>    '''                                                                     <span class=u>&#x2462;</span></a>
    if size &lt; 0:
<a>        raise ValueError('number must be non-negative')                     <span class=u>&#x2463;</span></a>

    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size &lt; multiple:
<a>            return '{0:.1f} {1}'.format(size, suffix)                       <span class=u>&#x2464;</span></a>

    raise ValueError('number too large')</code></pre>
<ol>
<li><code>'KB'</code>, <code>'MB'</code>, <code>'GB'</code> 이는 모두 각각 string 입니다.
<li>Function docstring이라고 부르는 것인데, 이것 역시 아무튼 string 입니다. 여러 줄에 걸쳐서 작성할 수 있습니다. 시작할때 따옴표 세개를 연속으로 사용하면 됩니다.
<li>Function docstring을 끝낼때도 역시 따옴표 세개를 연속으로 사용합니다.
<li>예외 메시지에도 string이 사용됩니다.
<li>아...이건..string 같긴한데...쩝. 이건 대체 뭘까요?
</ol>

파이썬 3에서는 특정 값을 string 내부에 포맷팅할 수 있습니다. 복잡한 예도 많지만, 일단 기본적으로 placeholder 하나를 사용하여 특정 값 하나를 string 에 넣어주는 예를 봅시다. 

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>username = 'mark'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>password = 'PapayaWhip'</kbd>                             <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>"{0}'s password is {1}".format(username, password)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>"mark's password is PapayaWhip"</samp></pre>
<ol>

<li>실제로 제가 사용하는 패스워드는 아니예요.
<li>여기서 많은 일이 벌어졌네요. 먼저 이 라인은 string literal 에 대한 메소드 호출입니다. <em>string은 객체</em>이고 객체는 메소드를 가지고 있습니다. 두번째, 이 메소드의 결과는 다시 string이 됩니다. 마지막으로, <code>{0}</code> 과 <code>{1}</code> 은 <i>replacement fields</i> 라고 부르는 것인데, <code><dfn>format</dfn>()</code>메소드 내부에 인자로 전달되는 것들로 치환됩니다.
</ol>

<h3 id=compound-field-names>Compound Field Names</h3>

<p>정수를 치환해주는 가장 간단한 예제를 보았습니다. <code>format()</code> 메소드의 인자 리스트에 인덱스를 사용하여 정수를 치환해주는 방식이었는데, 좀더 설명드리면 <code>{0}</code> 는 첫번째 인자를 치환하고 (예에서는 <var>username</var> 이었습니다), <code>{1}</code>는 두번째 인자 (예에서는 <var>password</var> 이었습니다) 를 치환하는 형식입니다. 물론 인자의 갯수만큼,그리고 원하는 만큼 리스트 인덱스를 더 넣을 수도 있습니다. 그러나 replacement field 에는 더 강력한 기능들이 있습니다. 

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>si_suffixes = humansize.SUFFIXES[1000]</kbd>      <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>si_suffixes</kbd>
<samp class=pp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'1000{0[0]} = 1{0[1]}'.format(si_suffixes)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'1000KB = 1MB'</samp>
</pre>
<ol>

<li><code>humansize</code> 모듈 안에 있는 함수를 호출하는 대신, 모듈 내부에 정의된 자료구조인 &#8220;SI&#8221; (1000의 제곱)만 불러 들였습니다.(powers-of-1000).
<li>얼핏 보기엔 복잡하지만, 그렇지 않습니다. <code>{0}</code> 은 <code>format()</code> 메소드에 넘겨진 첫번째 인자인 <var>si_suffixes</var>를 의미합니다. 하지만 <var>si_suffixes</var> 는 리스트입니다. 따라서 <code>{0[0]}</code>는 <code>format()</code> 메소드에 넘겨진 첫번째 인자인 해당리스트의 첫번째 아이템인 <code>'KB'</code>이 되는거죠. 한편, <code>{0[1]}</code> 는 같은 리스트의 두번째 아이템인 <code>'MB'</code>이구요. curly brace 바깥에 있는 모든 것들, 가령 숫자 <code>1000</code>, 등호표시(=), 그리고 빈칸은 변화가 없습니다. 따라서, 출력되는 string은 <code>'1000KB = 1MB'</code>이 됩니다.
</ol>

<aside>{0} 은 format() 메소드의 1<sup>st</sup> 인자로 대체되고. {1} 은 2<sup>nd</sup>인자로 대체됩니다.</aside>

<p>이 예제가 보여주듯이 <em>format specifiers 는 파이썬 문법을 통하면 거의 모든 파이썬 자료구조의 특성과 각 개별 아이템들에 접근할 수 있습니다</em>. 이를 가르켜 <i>compound field names</i> 이라고 하고, 다음과 같은 compound field names 들이&#8220;가능합니다&#8221;:

<ul>
<li>리스트를 넘겨주고, 리스트의 아이템을 인덱스를 통해 접근합니다 (앞의 예처럼요)
<li>딕셔너리를 넘겨주고 딕셔너리의 키 값을 이용하여 해당 값을 참조할 수 있습니다
<li>모듈을 넘겨주고, 모듈 내부의 변수와 함수를 그 이름을 이용하여 참조할 수 있습니다 
<li>클래스 인스턴스를 넘겨주고, 이 인스턴스의 프로퍼티와 메소드를 그 이름을 이용하여 참조할 수 있습니다
<li><em>앞에 열거된 방법들을 모두 섞어서 사용하는 것도 가능합니다</em>
</ul>


<p>그럼 실제로 어떻게 사용가능한지 예제를 통해 알아봅시다:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<samp class=p>>>> </samp><kbd class=pp>import sys</kbd>
<samp class=p>>>> </samp><kbd class=pp>'1MB = 1000{0.modules[humansize].SUFFIXES[1000][0]}'.format(sys)</kbd>
<samp class=pp>'1MB = 1000KB'</samp></pre>

<p>이제 코드에 대한 설명을 보시죠

<ul>

<li><code>sys</code> 모듈을 먼저 임포트 했습니다. 이 모듈은 현재 실행중인 파이썬 인스턴스에 대한 정보를 가지고 있습니다. 이 모듈 자체를 <code>format()</code> 메소드에 인자로 넘겨주었으므로, replacement field <code>{0}</code> 은 이제 <code>sys</code> 모듈을 가르킵니다.

<li><code>sys.modules</code>은 딕셔너리 자료형으로서, 현재 실행중인 파이썬 인스턴스에게로 임포트된 모든 모듈을 키-값 형태로 가지고 있습니다. 키는 모듈의 이름으로 string 타입이며, 값은 모듈 객체로 객체 타입입니다. 따라서 replacement field <code>{0.modules}</code>는 import 된 모듈의 딕셔너리가 됩니다.

<li><code>sys.modules['humansize']</code> 는 앞의 예에서 import 했던 <code>humansize</code> 모듈을 가르킵니다. The replacement field <code>{0.modules[humansize]}</code> 도 <code>humansize</code> 모듈을 가르킵니다. 문법이 살짝 다른 부분이 있는데, 실제 파이썬 코드에서 <code>sys.modules</code> 딕셔너리의 키인 모듈 이름의 타입은 string 입니다. 따라서, 이 키 값을 지칭하려면 모듈 이름을 <code>'humansize'</code> 와 같이 따옴표로 감싸줘야 합니다. 그리나 replacement field 에서는, <code>humansize</code>와 같이 따옴표를 사용하지 않았습니다. <a href=http://www.python.org/dev/peps/pep-3101/>PEP 3101: Advanced String Formatting</a>, 에서는 다음과 같이 정의하고 있기 때문입니다.&#8220;아이템 키를 파싱하기 위한 룰은 간단하게 키 값이 숫자로 시작하면 숫자로 취급하고, 그 외의 경우는 모두 문자로 취급한다.&#8221;

<li><code>sys.modules['humansize'].SUFFIXES</code> 는 <code>humansize</code> 모듈내에서 최상위 레벨에 정의된 딕셔너리 자료구조입니다. The replacement field <code>{0.modules[humansize].SUFFIXES}</code> 은 이를 가르킵니다.
<li><code>sys.modules['humansize'].SUFFIXES[1000]</code> 은 <abbr>SI</abbr> 리스트로  <code>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</code>를 가르킵니다. 따라서 replacement field <code>{0.modules[humansize].SUFFIXES[1000]}</code> 은 이 리스트를 가리킵니다.
<li><code>sys.modules['humansize'].SUFFIXES[1000][0]</code> 는 <abbr>SI</abbr> 리스트의 첫번째 아이템인 <code>'KB'</code> 를 가르킵니다. 따라서 최종 replacement field <code>{0.modules[humansize].SUFFIXES[1000][0]}</code>는 이 두 개의 문자로 이루어진 string인 <code>KB</code>를 의미합니다.
</ul>

<h3 id=format-specifiers>Format Specifiers</h3>

<p>잠깐만요. 아직 끝난게 아니예요. <code>humansize.py</code>를 다시 한번 의심스런 눈초리로 바라봅시다:
<p>But wait! There&#8217;s more! Let&#8217;s take another look at that strange line of code from <code>humansize.py</code>:

<pre class='nd pp'><code>if size &lt; multiple:
    return '{0:.1f} {1}'.format(size, suffix)</code></pre>


<p><code>{1}</code> 는 <code>format()</code> 메소드의 두번째 파라미터인 <var>suffix</var> 로 대체됩니다. 그런데 <code>{0:.1f}</code>은 뭐죠? 일단 두 부분으로 나눠서 생각할 수 있겠네요. <code>{0}</code>은 첫번째 파라미터로 대체 되는건 알겠죠? 그런데 <code>:.1f</code> 는 아리송하군요. 이건 <i>format specifier</i>라고 부르는 것인데요, 대체된 변수가 디스플레이될 때 어떤 방식으로 되야 하는지를 정의하는 구문입니다.


<blockquote class='note compare clang'>
<p><span class=u>&#x261E;</span>Format specifiers는 대체되는 텍스트를 다양한 방식으로 표현할 수 있도록 해줍니다. C 언어의 <code><dfn>printf</dfn>()</code> 함수와 같이 자릿수를 추가한다던지, 글자 사이에 빈칸을 넣거나, 심지어 10진수를 16진수로 변환할 수도 있습니다. </blockquote>


<p>replacement field 내에서 콜론은(<code>:</code>) format specifier가 시작하는 부분을 의미합니다. Format specifier &#8220;<code>.1</code>&#8221; 은 &#8220;소숫점 1의 자리에서 반올림 하라&#8221;는 의미입니다. (<i>즉</i> 소숫점 뒤의 한 자리만 나타내라는 것이죠). Format specifier &#8220;<code>f</code>&#8221; 는 &#8220;fixed-point number&#8221; 라는 뜻이고요. 따라서, 이를 주어진 <var>크기</var>의 숫자 <code>698.24</code> 와<var>접미어</var> <code>'GB'</code>에 적용하면, formatted string은 <code>'698.2 GB'</code>이 됩니다.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>'{0:.1f} {1}'.format(698.24, 'GB')</kbd>
<samp class=pp>'698.2 GB'</samp></pre>

<p>format specifier에 대해 더 자세한 내용은 파이썬 공식 문서인 <a href=http://docs.python.org/3.1/library/string.html#format-specification-mini-language>Format Specification Mini-Language</a>를 참고하시기 바랍니다.

<p class=a>&#x2042;

<h2 id=common-string-methods>Other Common String Methods</h2>

<p>Besides formatting, strings can do a number of other useful tricks.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>s = '''Finished files are the re-</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd>sult of years of scientif-</kbd>
<samp class=p>... </samp><kbd>ic study combined with the</kbd>
<samp class=p>... </samp><kbd>experience of years.'''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.splitlines()</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>['Finished files are the re-',
 'sult of years of scientif-',
 'ic study combined with the',
 'experience of years.']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(s.lower())</kbd>                   <span class=u>&#x2462;</span></a>
<samp>finished files are the re-
sult of years of scientif-
ic study combined with the
experience of years.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.lower().count('f')</kbd>               <span class=u>&#x2463;</span></a>
<samp class=pp>6</samp></pre>
<ol>
<li>You can input <dfn>multiline</dfn> strings in the Python interactive shell. Once you start a multiline string with triple quotation marks, just hit <kbd>ENTER</kbd> and the interactive shell will prompt you to continue the string. Typing the closing triple quotation marks ends the string, and the next <kbd>ENTER</kbd> will execute the command (in this case, assigning the string to <var>s</var>).
<li>The <code><dfn>splitlines</dfn>()</code> method takes one multiline string and returns a list of strings, one for each line of the original. Note that the carriage returns at the end of each line are not included.
<li>The <code>lower()</code> method converts the entire string to lowercase. (Similarly, the <code>upper()</code> method converts a string to uppercase.)
<li>The <code>count()</code> method counts the number of occurrences of a substring. Yes, there really are six &#8220;f&#8221;s in that sentence!
</ol>

<p>Here&#8217;s another common case. Let&#8217;s say you have a list of key-value pairs in the form <code><var>key1</var>=<var>value1</var>&amp;<var>key2</var>=<var>value2</var></code>, and you want to split them up and make a dictionary of the form <code>{key1: value1, key2: value2}</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>query = 'user=pilgrim&amp;database=master&amp;password=PapayaWhip'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = query.split('&amp;')</kbd>                                        <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['user=pilgrim', 'database=master', 'password=PapayaWhip']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list_of_lists = [v.split('=', 1) for v in a_list if '=' in v]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list_of_lists</kbd>
<samp class=pp>[['user', 'pilgrim'], ['database', 'master'], ['password', 'PapayaWhip']]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict = dict(a_list_of_lists)</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'password': 'PapayaWhip', 'user': 'pilgrim', 'database': 'master'}</samp></pre>

<ol>
<li>The <code><dfn>split</dfn>()</code> string method has one required argument, a delimiter. The method splits a string into a list of strings based on the delimiter. Here, the delimiter is an ampersand character, but it could be anything.
<li>Now we have a list of strings, each with a key, followed by an equals sign, followed by a value. We can use a <a href=comprehensions.html#listcomprehension>list comprehension</a> to iterate over the entire list and split each string into two strings based on the first equals sign. The optional second argument to the <code>split()</code> method is the number of times you want to split. <code>1</code> means &#8220;only split once,&#8221; so the <code>split()</code> method will return a two-item list. (In theory, a value could contain an equals sign too. If you just used <code>'key=value=foo'.split('=')</code>, you would end up with a three-item list <code>['key', 'value', 'foo']</code>.)
<li>Finally, Python can turn that list-of-lists into a dictionary simply by passing it to the <code>dict()</code> function.
</ol>

<blockquote class=note>
<p><span class=u>&#x261E;</span>The previous example looks a lot like parsing query parameters in a <abbr>URL</abbr>, but real-life <abbr>URL</abbr> parsing is actually more complicated than this. If you&#8217;re dealing with <abbr>URL</abbr> query parameters, you&#8217;re better off using the <a href=http://docs.python.org/3.1/library/urllib.parse.html#urllib.parse.parse_qs><code>urllib.parse.parse_qs()</code></a> function, which handles some non-obvious edge cases.
</blockquote>

<h3 id=slicingstrings>Slicing A String</h3>
<p>Once you&#8217;ve defined a string, you can get any part of it as a new string. This is called <i>slicing</i> the string. Slicing strings works exactly the same as <a href=native-datatypes.html#slicinglists>slicing lists</a>, which makes sense, because strings are just sequences of characters.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'My alphabet starts where your alphabet ends.'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[3:11]</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>'alphabet'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[3:-3]</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>'alphabet starts where your alphabet en'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[0:2]</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>'My'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[:18]</kbd>            <span class=u>&#x2463;</span></a>
<samp class=pp>'My alphabet starts'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[18:]</kbd>            <span class=u>&#x2464;</span></a>
<samp class=pp>' where your alphabet ends.'</samp></pre>
<ol>
<li>You can get a part of a string, called a &#8220;slice&#8221;, by specifying two indices. The return value is a new string containing all the characters of the string, in order, starting with the first slice index.
<li>Like slicing lists, you can use negative indices to slice strings.
<li>Strings are zero-based, so <code>a_string[0:2]</code> returns the first two items of the string, starting at <code>a_string[0]</code>, up to but not including <code>a_string[2]</code>.
<li>If the left slice index is 0, you can leave it out, and 0 is implied. So <code>a_string[:18]</code> is the same as <code>a_string[0:18]</code>, because the starting 0 is implied.
<li>Similarly, if the right slice index is the length of the string, you can leave it out. So <code>a_string[18:]</code> is the same as <code>a_string[18:44]</code>, because this string has 44 characters.  There is a pleasing symmetry here. In this 44-character string, <code>a_string[:18]</code> returns the first 18 characters, and <code>a_string[18:]</code> returns everything but the first 18 characters. In fact, <code>a_string[:<var>n</var>]</code> will always return the first <var>n</var> characters, and <code>a_string[<var>n</var>:]</code> will return the rest, regardless of the length of the string.
</ol>

<p class=a>&#x2042;

<h2 id=byte-arrays>Strings vs. Bytes</h2>

<p><dfn>Bytes</dfn> are bytes; characters are an abstraction. An immutable sequence of Unicode characters is called a <i>string</i>. An immutable sequence of numbers-between-0-and-255 is called a <i>bytes</i> object.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>by = b'abcd\x65'</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'abcde'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(by)</kbd>          <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'bytes'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>           <span class=u>&#x2462;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by += b'\xff'</kbd>     <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'abcde\xff'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>           <span class=u>&#x2464;</span></a>
<samp class=pp>6</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by[0]</kbd>             <span class=u>&#x2465;</span></a>
<samp class=pp>97</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by[0] = 102</kbd>       <span class=u>&#x2466;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'bytes' object does not support item assignment</samp></pre>
<ol>
<li>To define a <code>bytes</code> object, use the <code>b''</code> &#8220;<dfn>byte</dfn> literal&#8221; syntax. Each byte within the byte literal can be an <abbr>ASCII</abbr> character or an encoded hexadecimal number from <code>\x00</code> to <code>\xff</code> (0&ndash;255).
<li>The type of a <code>bytes</code> object is <code>bytes</code>.
<li>Just like lists and strings, you can get the length of a <code>bytes</code> object with the built-in <code>len()</code> function.
<li>Just like lists and strings, you can use the <code>+</code> operator to concatenate <code>bytes</code> objects. The result is a new <code>bytes</code> object.
<li>Concatenating a 5-byte <code>bytes</code> object and a 1-byte <code>bytes</code> object gives you a 6-byte <code>bytes</code> object.
<li>Just like lists and strings, you can use index notation to get individual bytes in a <code>bytes</code> object. The items of a string are strings; the items of a <code>bytes</code> object are integers. Specifically, integers between 0&ndash;255.
<li>A <code>bytes</code> object is immutable; you can not assign individual bytes. If you need to change individual bytes, you can either use <a href=#slicingstrings>string slicing</a> and concatenation operators (which work the same as strings), or you can convert the <code>bytes</code> object into a <code>bytearray</code> object.
</ol>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>by = b'abcd\x65'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>barr = bytearray(by)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>barr</kbd>
<samp class=pp>bytearray(b'abcde')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(barr)</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>barr[0] = 102</kbd>         <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>barr</kbd>
<samp class=pp>bytearray(b'fbcde')</samp></pre>
<ol>
<li>To convert a <code>bytes</code> object into a mutable <code>bytearray</code> object, use the built-in <code>bytearray()</code> function.
<li>All the methods and operations you can do on a <code>bytes</code> object, you can do on a <code>bytearray</code> object too.
<li>The one difference is that, with the <code>bytearray</code> object, you can assign individual bytes using index notation. The assigned value must be an integer between 0&ndash;255.
</ol>

<p>The one thing you <em>can never do</em> is mix bytes and strings.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>by = b'd'</kbd>
<samp class=p>>>> </samp><kbd class=pp>s = 'abcde'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>by + s</kbd>                       <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: can't concat bytes to str</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.count(by)</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: Can't convert 'bytes' object to str implicitly</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.count(by.decode('ascii'))</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>1</samp></pre>
<ol>
<li>You can&#8217;t concatenate bytes and strings. They are two different data types.
<li>You can&#8217;t count the occurrences of bytes in a string, because there are no bytes in a string. A string is a sequence of characters. Perhaps you meant &#8220;count the occurrences of the string that you would get after decoding this sequence of bytes in a particular character encoding&#8221;? Well then, you&#8217;ll need to say that explicitly. Python 3 won&#8217;t <dfn>implicitly</dfn> convert bytes to strings or strings to bytes.
<li>By an amazing coincidence, this line of code says &#8220;count the occurrences of the string that you would get after decoding this sequence of bytes in this particular character encoding.&#8221;
</ol>

<p>And here is the link between strings and bytes: <code>bytes</code> objects have a <code><dfn>decode</dfn>()</code> method that takes a character encoding and returns a string, and strings have an <code><dfn>encode</dfn>()</code> method that takes a character encoding and returns a <code>bytes</code> object. In the previous example, the decoding was relatively straightforward&nbsp;&mdash;&nbsp;converting a sequence of bytes in the <abbr>ASCII</abbr> encoding into a string of characters. But the same process works with any encoding that supports the characters of the string&nbsp;&mdash;&nbsp;even legacy (non-Unicode) encodings.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_string = '深入 Python'</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>len(a_string)</kbd>
<samp class=pp>9</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('utf-8')</kbd>    <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xe6\xb7\xb1\xe5\x85\xa5 Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>13</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('gb18030')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xc9\xee\xc8\xeb Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>11</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('big5')</kbd>     <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xb2`\xa4J Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>11</samp>
<a><samp class=p>>>> </samp><kbd class=pp>roundtrip = by.decode('big5')</kbd>    <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>roundtrip</kbd>
<samp class=pp>'深入 Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string == roundtrip</kbd>
<samp class=pp>True</samp></pre>
<ol>
<li>This is a string. It has nine characters.
<li>This is a <code>bytes</code> object. It has 13 bytes. It is the sequence of bytes you get when you take <var>a_string</var> and encode it in <abbr>UTF-8</abbr>.
<li>This is a <code>bytes</code> object. It has 11 bytes. It is the sequence of bytes you get when you take <var>a_string</var> and encode it in <a href=http://en.wikipedia.org/wiki/GB_18030>GB18030</a>.
<li>This is a <code>bytes</code> object. It has 11 bytes. It is an <em>entirely different sequence of bytes</em> that you get when you take <var>a_string</var> and encode it in <a href=http://en.wikipedia.org/wiki/Big5>Big5</a>.
<li>This is a string. It has nine characters. It is the sequence of characters you get when you take <var>by</var> and decode it using the Big5 encoding algorithm. It is identical to the original string.
</ol>

<p class=a>&#x2042;

<h2 id=py-encoding>Postscript: Character Encoding Of Python Source Code</h2>

<p>Python 3 assumes that your source code&nbsp;&mdash;&nbsp;<i>i.e.</i> each <code>.py</code> file&nbsp;&mdash;&nbsp;is encoded in <abbr>UTF-8</abbr>.

<blockquote class='note compare python2'>
<p><span class=u>&#x261E;</span>In Python 2, the <dfn>default</dfn> encoding for <code>.py</code> files was <abbr>ASCII</abbr>. In Python 3, <a href=http://www.python.org/dev/peps/pep-3120/>the default encoding is <abbr>UTF-8</abbr></a>.
</blockquote>

<p>If you would like to use a different encoding within your Python code, you can put an encoding declaration on the first line of each file. This declaration defines a <code>.py</code> file to be windows-1252:

<pre class='nd pp'><code># -*- coding: windows-1252 -*-</code></pre>

<p>Technically, the character encoding override can also be on the second line, if the first line is a <abbr>UNIX</abbr>-like hash-bang command.

<pre class='nd pp'><code>#!/usr/bin/python3
# -*- coding: windows-1252 -*-</code></pre>

<p>For more information, consult <a href=http://www.python.org/dev/peps/pep-0263/><abbr>PEP</abbr> 263: Defining Python Source Code Encodings</a>.

<p class=a>&#x2042;

<h2 id=furtherreading>Further Reading</h2>

<p>On Unicode in Python:

<ul>
<li><a href=http://docs.python.org/3.1/howto/unicode.html>Python Unicode HOWTO</a>
<li><a href=http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit>What&#8217;s New In Python 3: Text vs. Data Instead Of Unicode vs. 8-bit</a>
<li><a href=http://www.python.org/dev/peps/pep-0261/><abbr>PEP 261</abbr></a> explains how Python handles astral characters outside of the Basic Multilingual Plane (<i>i.e.</i> characters whose ordinal value is greater than 65535)
</ul>

<p>On Unicode in general:

<ul>
<li><a href=http://www.joelonsoftware.com/articles/Unicode.html>The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/06/Unicode>On the Goodness of Unicode</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/13/Strings>On Character Strings</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF>Characters vs. Bytes</a>
</ul>

<p>On character encoding in other formats:

<ul>
<li><a href=http://feedparser.org/docs/character-encoding.html>Character encoding in XML</a>
<li><a href=http://blog.whatwg.org/the-road-to-html-5-character-encoding>Character encoding in HTML</a>
</ul>

<p>On strings and string formatting:

<ul>
<li><a href=http://docs.python.org/3.1/library/string.html><code>string</code>&nbsp;&mdash;&nbsp;Common string operations</a>
<li><a href=http://docs.python.org/3.1/library/string.html#formatstrings>Format String Syntax</a>
<li><a href=http://docs.python.org/3.1/library/string.html#format-specification-mini-language>Format Specification Mini-Language</a>
<li><a href=http://www.python.org/dev/peps/pep-3101/><abbr>PEP</abbr> 3101: Advanced String Formatting</a>
</ul>

<p class=v><a href=comprehensions.html rel=prev title='back to &#8220;Comprehensions&#8221;'><span class=u>&#x261C;</span></a> <a href=regular-expressions.html rel=next title='onward to &#8220;Regular Expressions&#8221;'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
