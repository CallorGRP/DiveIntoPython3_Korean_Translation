<!DOCTYPE html>
<meta charset=utf-8>
<title>처음 만나는 파이썬 프로그램 - Dive Into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 1}
table{border:1px solid #bbb;border-collapse:collapse;margin:auto}
td,th{border:1px solid #bbb;padding:0 1.75em}
th{text-align:left}
mark{display:inline}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#your-first-python-program>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>Difficulty level: <span class=u title=novice>&#x2666;&#x2662;&#x2662;&#x2662;&#x2662;</span>
<h1>처음 만나는 파이썬 프로그램</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Don&#8217;t bury your burden in saintly silence. You have a problem?  Great. Rejoice, dive in, and investigate. <span class=u>&#x275E;</span>
<br>
당신의 짐을 고요한 침묵속에 묻어두지 마라. 문제가 있는가? 좋다. 기뻐하고, 뛰어들어, 탐구하자! <br>&mdash; <a href=http://en.wikiquote.org/wiki/Buddhism>Ven. Henepola Gunaratana</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Diving In</h2>
<p class=f>

    대부분의 프로그래밍 학습서 진도대로 나가자면, 지루한 자료형부터 시작해서 프로그래밍의 기본 원리라던지, 어떻게 해야 간단한 채팅 프로그램이라도 만들 수 있는지에 대한 순서대로 설명해야 될 겁니다. 하지만, 모두 잠시 접어두고 그냥 한번 파이썬 코드를 쳐다봅시다. 네, 알고 있습니다. 어쩌면 한줄도 이해 못할 수도 있죠. 그래도 너무 걱정 마시고, 손해보는 셈치고 그냥 한번 읽어 보세요. 제가 이제부터 친절하게 한줄 한줄 설명해 드릴꺼니까요. 



<p class=d>[<a href=examples/humansize.py>download <code>humansize.py</code></a>]
<pre class=pp><code>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}

def approximate_size(size, a_kilobyte_is_1024_bytes=True):
    '''Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

    '''
    if size &lt; 0:
        raise ValueError('number must be non-negative')

    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size &lt; multiple:
            return '{0:.1f} {1}'.format(size, suffix)

    raise ValueError('number too large')

if __name__ == '__main__':
    print(approximate_size(1000000000000, False))
    print(approximate_size(1000000000000))</code></pre>
<p>
    이제 이 프로그램을 커맨드라인에서 실행해 봅시다. 마이크로소프트 윈도우즈에서는 아래처럼 되겠죠?
<pre class='nd screen'>
<samp class=p>c:\home\diveintopython3\examples> </samp><kbd>c:\python31\python.exe humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>

<p>
    맥 OS X나 Linux에서는, 이렇게 쓰세요
<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>

<p>
    축하드립니다. 짝짝짝. 방금 여러분들께서는 처음으로 파이썬 프로그램을 실행시킨 겁니다. 명령행에서 파이썬 실행기를 불러왔고, 실행시킬 파이썬 스크립트 파일의 이름을 넘겨줬습니다. 그 스크립트 안에는 함수 하나가 정의되어 있었는데요, 바이트 단위의 파일 크기를 근사치의, 사람이 읽기 편한 포맷으로 변환해주는 <code>approximate_size()</code>라는 함수입니다. (이런 기능을 아마 윈도우 익스플로러나 맥 OS X의 파인더, 아니면 리눅스의 노틸러스나 Dolphon, Thunar등의 어플리케이션을 통해 보신 분도 있을 겁니다. 문서 폴더에서 자세히 보기를 선택하면 문서의 아이콘, 이름, 크기, 형태, 최근 수정일 등이 나타나게 되죠. 만약 폴더에 <code>TODO</code>라는 1093바이트 크기의 파일이 있다면, <code>TODO 1093 bytes</code> 라고 나타나는 대신 <code>TODO 1 KB</code> 라고 나타납니다. 바로 이런 게 <code>approximate_size()</code> 함수가 하는 일입니다.)



<p>
    스크립트 아랫 부분을 보면 <code>print(approximate_size(<var>arguments</var>))</code> 라고 되있는 코드를 볼 수 있습니다. 전형적인 함수 호출인데요, &mdash; 우선 <code>approximate_size()</code> 함수에 파라미터를 넘겨서 호출하고, 리턴된 결과값을 바로 <code>print()</code> 함수에 넘겨줬습니다. <code>print()</code> 는 기본으로 제공되는 함수라서 따로 선언할 필요가 없습니다. 이런 기본 제공 함수(built-in function)는 그냥 언제 어디서든 사용할 수 있습니다. (파이썬은 다양한 기본 제공 함수들을 가지고 있지만, 훨씬 더 다양한 함수들이 파이썬 <i>모듈</i>들 아래 또아리를 틀고 있습니다. 그럼 어떤 모듈이 있는지 궁금하기겠죠? 자자. 조금만 기다리세요. 먼저 공부하던것 부터 끝내구요.)

<p>

    그런데 이 스크립트를 실행시키면, 왜 항상 같은 결과가 나올까요? 이제부터 이것에 대해 알아볼 겁니다. 먼저, <code>approximate_size()</code> 함수를 봅시다.







<p class=a>&#x2042;

<h2 id=declaringfunctions>함수 선언</h2>

<p>
    파이썬도 다른 언어들과 마찬가지로 함수가 있습니다. 하지만 <abbr>C++</abbr>처럼 함수를 위한 별도의 헤더 파일도 없고, 파스칼처럼 <code>interface</code>와 <code>implementation</code>이 분리되어 있지도 않습니다. 파이썬에서는 함수가 필요하면 그냥 그 자리에서 선언합니다.:
<pre class='nd pp'><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):</code></pre>

<aside>함수가 필요하면, 그냥 선언하세요!</aside>
<p>
    파이썬의 함수 선언은 <code>def</code>라는 키워드로 시작하고, 그 뒤에 함수 이름, 괄호가 차례로 나옵니다. 괄호 안에는 파라미터를 적어주고, 파라미터가 여러 개라면 콤마를 사용해 구분합니다.

<p>
    한편, 파이썬 함수 선언시 반환 값의 타입을 별도로 지정하지 않는다는 점에 주의하세요. 심지어 어떤 값을 리턴하는지 아닌지도 지정할 필요가 없습니다.  (사실, 모든 파이썬 함수는 어떤 값을 반환합니다. 만약 함수내에 <code>return</code>문이 사용되었다면 해당하는 그 값을 돌려주고, return 문이 없다면 <code>None</code>이라고 하는 파이썬에서 지정한 null 값을 돌려줍니다.)
<blockquote class=note>

<p>
    <span class=u>&#x261E;</span>어떤 언어는 값을 돌려주는 함수는 <code>function</code>이라는 키워드로 선언을 시작하고, 값을 반환하지 않는 단순 서브루틴(subroutine) 코드은 <code>sub</code>라는 키워드로 시작합니다. 하지만, 파이썬에는 서브루틴 같은 개념은 없습니다. 모든 것은 함수이고, 모든 함수는 None이건 뭐건 간에 어쨌든 값을 반환합니다. 그리고 모든 함수는 <code>def</code>라는 키워드로 시작합니다.
</blockquote>
<p>
    여기서 <code>approximate_size()</code> 함수는 <var>size</var> 와 <var>a_kilobyte_is_1024_bytes</var>라는 두개의 파라미터를 받습니다. 두 파라미터 모두 자료형을 명시하지 않았습니다. 파이썬에서는 변수의 자료형을 별도로 선언하지 않습니다. 왜냐하면 파이썬이 변수의 형태를 내부적으로 유추하여 알아낸 후 내부적으로 기억하고 있기 때문입니다.
<blockquote class='note compare java'>

<p>
    <span class=u>&#x261E;</span>Java 같은 정적 타입 언어에서는, 함수 리턴 값과 파라미터의 자료형을 반드시 명시해 주어야 합니다. 그러나 파이썬같은 동적 타입 언어에서는 따로 자료형을 명시할 필요가 없습니다. 변수나 함수에 할당된 값을 통해 그 자료형을 알아내고, 또 기억하기 때문입니다.
</blockquote>

<h3 id=optional-arguments>추가적이거나 이름을 가지는 넘김값</h3>

<p>
    파이썬에서는 함수 선언시 파라미터에 디폴트 값을 넘겨 줄 수 있습니다. 만약 함수가 호출시 파라미터가 없다면, 지정된 디폴트 파라미터로 대체됩니다. 그리고 named argument 를 사용하면 함수 인자의 순서를 꼭 지키지 않아도 됩니다.

<p>
    <code>approximate_size()</code>함수의 선언부를 다시 한번 살펴보죠: 

<pre class='nd pp'><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):</code></pre>

<p>
    여기서 두번째 파라미터 <var>a_kilobyte_is_1024_bytes</var>는 <code>True</code>라는 기본값을 가지고 있는데, 이렇게 지정하면 이 파라미터는 반드시 지정하지 않아도 됩니다. 함수 호출시 이 파라미터 없이 호출할 수 있다는 뜻이고, 실제로 그렇게 호출하면 파이썬은 두번째 파라미터가 들어갈 자리에 <code>True</code>를 넣고 동작합니다.

<p>
    이제 스크립트의 맨 아래 부분를 봅시다

<pre class=pp><code>if __name__ == '__main__':
<a>    print(approximate_size(1000000000000, False))  <span class=u>&#x2460;</span></a>
<a>    print(approximate_size(1000000000000))         <span class=u>&#x2461;</span></a></code></pre>

<ol>
<li>
    처음으로 <code>approximate_size()</code>를 부를 때는 두 파라미터 모두 전달했습니다. 두번째 파라미터의 값으로 <code>False</code>를 넘겼기 때문에 <code>approximate_size()</code>함수의 <var>a_kilobyte_is_1024_bytes</var>는 <code>False</code>가 됩니다.
<li>
    두번째로 <code>approximate_size()</code>함수를 부를 때는, 하나의 파라미터만을 전달했습니다. 두번째 파라미터에 꼭 값을 넘겨줄 필요가 없기 때문에 괜찮습니다. 함수 호출 쪽에서 따로 두번째 파라미터를 지정하지 않았기 때문에, 그 값은 함수 선언에 따라 자연히 <code>True</code>가 됩니다.
</ol>

<p>
    한편 이름을 가지고 함수에 값을 전달할수도 있습니다.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>from humansize import approximate_size</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(4000, a_kilobyte_is_1024_bytes=False)</kbd>       <span class=u>&#x2460;</span></a>
<samp class=pp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(size=4000, a_kilobyte_is_1024_bytes=False)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(a_kilobyte_is_1024_bytes=False, size=4000)</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'4.0 KB'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(a_kilobyte_is_1024_bytes=False, 4000)</kbd>       <span class=u>&#x2463;</span></a>
<samp class=traceback>  File "&lt;stdin>", line 1
SyntaxError: non-keyword arg after keyword arg</samp>
<a><samp class=p>>>> </samp><kbd class=pp>approximate_size(size=4000, False)</kbd>                           <span class=u>&#x2464;</span></a>
<samp class=traceback>  File "&lt;stdin>", line 1
SyntaxError: non-keyword arg after keyword arg</samp></pre>
<ol>
<li>
    이번 <code>approximate_size()</code> 함수호출에 첫번째 파라미터인 (<var>size</var>)에 <code>4000</code>을 넣고, <var>a_kilobyte_is_1024_bytes</var> 에는 <code>False</code>를 넣었습니다.
<li>
    이번 <code>approximate_size()</code> 함수 호출에는 <var>size</var> 파라미터에 <code>4000</code>을, <var>a_kilobyte_is_1024_bytes</var> 파라미터에는 <code>False</code>를 각각 넣습니다. (함수 선언부에서의 파라미터 순서와 같지만, 순서는 별로 중요하지 않습니다.)
<li>
    이번 <code>approximate_size()</code> 함수 호출에는 먼저 <var>a_kilobyte_is_1024_bytes</var>에 <code>False</code>값을 넣고  <var>size</var>에 <code>4000</code>을 넣습니다. (순서는 중요하지 않다고 말했죠?)
<li>
    이 코드는 에러입니다. 한번 파라미터의 이름을 사용했으면, 그 뒤에 등장하는 파라미터에도 파라미터 이름을 사용해야 합니다. 
<li>
    앞과 같은 이유로 이번 함수호출도 실패입니다. 놀라셨나요? 얼핏보기에 <code>size</code>에 <code>4000</code>이란 값을 주었고, 그리고 그 뒤에 등장하는 <code>False</code>가 의미하는 것도 분명해 보이지만, 파이썬은 그렇게 동작하지 않습니다. 일단 하나의 파라미터에 이름을 주었으면, 그 뒤에 나오는  모든 파라미터들도 이름을 명시해줘야 합니다.
</ol>

<p class=a>&#x2042;


    여기서부터 시작 (8월 8일)

    

<h2 id=readability>가독성 좋은 코드 작성하기</h2>
<p>
    코드 문서화의 중요성에 대해 지루하게 설명드리고 싶지는 않습니다. 다만 이것 하나만 명심하세요. 코드는 대부분 한번 작성되고 나면 수정되는 일이 많지 않습니다. 하지만, 동료가 되었건 내가 되었건 간에 작성된 코드는 한동안 읽히기 마련입니다. 혹시 코드를 짜고나서 6 개월 후에 읽어본 적이 있나요? 내가 왜 이렇게 짰는지 기억도 가물가물하지만, 내일 아침까지 당장 버그를 수정해야 하는 그런 상황말입니다. 하지만 걱정마세요. 파이썬엔 코드를 술술 읽힐수 있도록 작성할 수 있는 기능이 탑재되있습니다. 놀랍죠? 그러니 마구 써먹자고요. 아마 곧 제게 감사하게 될겁니다.

    <h3 id=docstrings>documentation string</h3>

<p>
    함수에 커멘트를 달고 싶으면 document string을 추가해주면 됩니다.(이를 줄여서 docstring 이라고 부릅니다). 아래 <code>approximate_size()</code> 이라는 함수는 <code>docstring</code>을 가지고 있습니다.

<pre class='nd pp'><code>def approximate_size(size, a_kilobyte_is_1024_bytes=True):
    '''Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

    '''</code></pre>
<aside>가능한 한 함수엔 적당한 docstring 을 달아주세요</aside>

<p>
    여러 줄에 걸쳐 docstring 을 달고 싶으면, 따옴표를 연달아 세 개 쓰면 됩니다. 그 사이에 나오는 모든 문자열 (줄바꿈이나 공백, 그리고 따옴표 등등)은 하나의 docstring 으로 간주됩니다. 이렇게 세겹 따옴표를 이용한 커멘트는 docstring 뿐만 아니라, 어디서든 사용할 수 있지만, 역시 주로 사용되는 곳은  <code>docstring</code>을 정의할 때 입니다.  
<blockquote class='note compare perl5'>
<p><span class=u>&#x261E;</span>세겹 따옴표를 이용하면, 홑따옴표와 곁따옴표가 포함된 문자열을 쉽게 정의할 수 있습니다. 펄(Pearl) 5의 <code>qq/.../</code> 처럼 말이죠.
</blockquote>

<p>
    세겹 따옴표로 정의된 문자열은 함수가 하는 일을 적어둔 <code>docstring</code>입니다. <code>docstring</code>은 반드시 함수 본문 내에서 처음으로 정의되는 객체여야 합니다.(코드 상으로는 함수 선언 바로 다음 줄에 써줘야 합니다). docstring을 정의하는 것이 의무는 아니지만, 가능한 한 달아주세요. 뭐 이런 얘기는 이미 귀가 따갑도록 들으셨으리라 생각합니다. 하지만, 파이썬의 docstring 은 단순한 주석문이 아닙니다.: 
<br>놀랍게도, docstring은 함수의 어트리뷰트 가운데 하나입니다. 그러니까, 런타임에 호출할 수 있습니다.
<blockquote class=note>

<p>
    <span class=u>&#x261E;</span>많은 파이썬 <abbr>통합개발환경(IDE, Integrated Development Environment)</abbr>들이 <code>docstring</code>을 적극적으로 활용합니다. 가령 특정 함수 이름을 타이핑하기 시작하면, 툴팁으로 함수의 <code>docstring</code>이 보여주기도 합니다. 물론, 얼마나 성의있게 잘 작성해 두었는지에 따라 유용할 수도 있고 아닐 수도 있을겁니다.
</blockquote>
<p class=a>&#x2042;

<h2 id=importsearchpath><code>import</code> 검색 경로</h2>

<p>
    파이썬 라이브러리 검색 경로에 대해 잠깐 짚어 보겠습니다. 파이썬은 모듈을 import 할 때 몇 가지 경로를 우선적으로 검색합니다. 정확히 말하면 <code>sys.path</code>에 정의되있는 모든 디렉토리를 뒤져봅니다. 이 디렉토리 목록은 리스트(list)로 저장되있기 때문에, 일반적인 리스트 처리 함수들을 통해 쉽게 읽고  쓸 수 있습니다. (리스트에 대해서는 <a href=native-datatypes.html#lists>고유 자료형</a>장에서 자세히 알아보겠습니다.)
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import sys</kbd>                                                 <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>sys.path</kbd>                                                   <span class=u>&#x2461;</span></a>
<samp class=pp>['', 
 '/usr/lib/python31.zip', 
 '/usr/lib/python3.1',
 '/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@', 
 '/usr/lib/python3.1/lib-dynload', 
 '/usr/lib/python3.1/dist-packages', 
 '/usr/local/lib/python3.1/dist-packages']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>sys</kbd>                                                        <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;module 'sys' (built-in)></samp>
<a><samp class=p>>>> </samp><kbd class=pp>sys.path.insert(0, '/home/mark/diveintopython3/examples')</kbd>  <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>sys.path</kbd>                                                   <span class=u>&#x2464;</span></a>
<samp class=pp>['/home/mark/diveintopython3/examples', 
 '', 
 '/usr/lib/python31.zip', 
 '/usr/lib/python3.1', 
 '/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@', 
 '/usr/lib/python3.1/lib-dynload', 
 '/usr/lib/python3.1/dist-packages', 
 '/usr/local/lib/python3.1/dist-packages']</samp></pre>
<ol>

<li>
    <code>sys</code> 모듈에 있는 함수와 속성을 사용하기 위해서는 먼저 모듈을 import 해야 합니다.
<li>
    <code>sys.path</code>는 현재 검색 경로로 지정된 디렉토리들이 리스트 형태로 저장되 있습니다. (PC의 OS나 설치한 파이썬 버전, 디렉토리 위치에 따라 예제에서와는 다를 수도 있습니다.) 우리가 모듈을 import 할때, 파이썬  내부에서는 import 모듈과 같은 이름을 가진 <code>.py</code> 파일을 찾기위해 이 디렉토리들을 차례대로 검색합니다.
<li>
    죄송합니다. 모든 모듈이 <code>.py</code> 파일로 되있는건 아닙니다. 앞에서 살짝 거짓말을 했습니다. 사실은 좀 더 복잡하거든요. sys 모듈 같은건 내장(Built-in) 모듈인데요, 내장 모듈은 파이썬 내부에 구현되 있어서, 소스 코드를 볼 수 없습니다. 내장 모듈도 import 해야 사용할 수 있는 등, 그 사용법은 다른 모듈들과 크게 다르지 않지만, 차이점은 내장 모듈은 파이썬이 아니라 C 언어로 작성되있고, 파이썬 안에 구현되있다는 것입니다. (파이썬 자체도 C 언어로 작성되었습니다.)
<li>
    런타임에 <code>sys.path</code>에 원하는 디렉토리명을 추가하여, 파이썬 검색 경로에 지정한 디렉토리를 설정할 수 있습니다. 이렇게 한 다음부터는 모듈 import시 지정한 디렉토리 내부 역시 라이브러리 검색경로가 됩니다. 이느 파이썬이 실행되는 동안만 유효합니다.
<li>
    <code>sys.path.insert(0, <var>new_path</var>)</code>라고 작성하면, new_path가 <code>sys.path</code>라는 리스트의 첫번째 인덱스 항목으로 추가됩니다. 파이썬 모듈 검색 경로의 맨 앞에 위치하게 되기 때문에, 이렇게 해주면 실행속도가 조금이라도 더 나을겁니다. 같은 이름의 모듈이 있어서 충돌이 나는 경우(예를 들어, 어떤 라이브러리의 파이썬 2 버전 대신 파이썬 3 버전으로 사용하고 싶을 때), 이렇게 검색경로의 맨 앞에 원하는 디렉토리를 추가해주면, 파이썬이 설치될 때 디폴트로 셋팅된 모듈보다 직접 추가한 모듈을 먼저 찾게 됩니다.
</ol>









<p class=a>&#x2042;

<h2 id=everythingisanobject>파이썬에선 모든 것이 객체입니다</h2>
<p>
    앞에서 이미 알려 드렸지만, 다시 한번 말씀드립니다. 파이썬 함수는 attribute를 가지고 있고, 이 attribute는 실행 시 사용할 수 있습니다. 네. 맞습니다. 파이썬 함수도 파이썬의 다른 것들처럼 객체입니다. 파이썬에선 모든게 객체라고요.

<p>
    파이썬 쉘을 열어서 다음 코드를 작성해 보세요:
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>                               <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(humansize.approximate_size(4096, True))</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>4.0 KiB</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(humansize.approximate_size.__doc__)</kbd>      <span class=u>&#x2462;</span></a>
<samp>Convert a file size to human-readable form.

    Keyword arguments:
    size -- file size in bytes
    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024
                                if False, use multiples of 1000

    Returns: string

</samp></pre>
<ol>

<li>
    <code>humansize</code> 프로그램을 모듈(필요시 꺼내 쓰거나 다른 파이썬 프로그램에서 사용할 수 있는 코드 묶음)로 import 합니다. import 된 모듈은 그 모듈에서 제공하는 모든 퍼블릭 함수나 클래스, 속성 등이 참조될 수 있습니다. 모듈 또한 다른 모듈의 기능을 import 해 사용할 수 있고, 이를 그때 그때 파이썬 쉘을 이용해 테스트 코드를 작성할 수도 있습니다. 이런 컨셉이 얼마나 중요하고, 또 다른 프로그래밍 언어와 어떻게 다른지, 앞으로 더 많은 예를 보여드리겠습니다.
<li>
    모듈 안에 정의된 함수를 사용할 때, 모듈의 이름도 같이 써줘야 합니다. <code>approximate_size</code>라고 하면 안되고 <code>humansize.approximate_size</code>와 같이 작성해야 합니다. 자바(Java) 클래스를 써본 적이 있다면 그것과 비슷하다는 걸 알아차리셨을 겁니다.
<li>
    함수 호출 대신, 함수의 속성인 <code>__doc__</code>을 호출했습니다.
</ol>
<blockquote class='note compare perl5'>
<p>
    <span class=u>&#x261E;</span>파이썬의 <code>import</code>는 펄의 <code>require</code>와 비슷합니다. 파이썬에서 모듈을 import 하면 <code><var>모듈</var>.<var>함수</var></code>와 같은 문법을 이용해 그 함수를 호출합니다. 펄에서 모듈을 require 하면, <code><var>모듈</var>::<var>함수</var></code> 와 같은 문법을 사용해 그 함수를 호출합니다. 많이 닮았죠?
</blockquote>
<h3 id=whatsanobject>객체가 뭔가요?</h3>

<p>
    파이썬에서는 모든 것은 객체라고 했기 때문에, 모든 것은 객체의 특징인 속성과 메소드를 가집니다. 예를 들어, 파이썬의 함수는 <var>docstring</var>을 반환하는 <code>__doc__</code> 이라는 기본 속성(Built-in attribute)을 가지고 있습니다. 한편 <code>sys</code> 모듈도 일종의 객체고, 속성중에는 <var>path</var>라는 속성도 가지고 있습니다. 그외에도 파이썬에는 여러 다른 객체 타입들이 있습니다.
<p>
    흠. 여전히 아리송하죠? 제가 계속해서 파이썬에선 모든 것이 객체입니다 라고 주구장창 떠들고 있는데요, 그보다 먼저 객체의 정의에 대해 생각해봐야 할것 같습니다. 사실 프로그래밍 언어들 마다 객체에 대한 정의는 조금씩 다릅니다. 어떤 언어는 객체가 무조건 속성과 메소드를 가져야 한다고 정의합니다. 다른 언어에서는 객체가 하위 클래스를 가질 수 있어야 합니다. 이에 반해 파이썬에서 객체에 대해 내리는 정의는 다른 프로그래밍 언어보다 조금 유연합니다. 파이썬의 객체는 속성과 메소드를 가질 수도 있고 아닐 수도 있습니다. 그리고 모든 객체가 하위클래스를 반드시 가져야 하는 것은 아닙니다. 그러나 분명한 건 파이썬에서의 객체란 변수에 할당할 수 있거나, 함수에 인자로 넘길 수 있는, 그런 어떤 모든 것입니다. 
<p>
    다른 프로그래밍 언어를 통해 &#8220;first class object&#8221; (역자 주: 객체가 할 수 있도록 정의된 모든 일을 제한없이 할 수 있는 객체. 이에 반해 부분적으로만 할 수 있는 객체를 second class object라고 함) 라는 말을 들어본 적이 있을겁니다. 파이썬 함수는 first-class object 입니다. 즉 함수를 다른 함수의 인자로 넘길 수 있습니다. 파이썬의 모듈도 first class object입니다. 함수의 인자로 모듈 전체를 넘기는 일도 가능합니다. 파이썬의 클래스도 first class object고, 클래스 인스턴스도 first class object입니다.
<p>
    파이썬에선 전부 다 객체다: 이 개념은 매우 중요하기 때문에 한동안 계속 떠들겁니다. string은 객체입니다. 리스트도 객체입니다. 함수도 객체입니다. 클래스도 객체입니다. 클래스 인스턴스도 객체입니다. 심지어 모듈도 객체입니다.
<p class=a>&#x2042;

<h2 id=indentingcode>코드 들여쓰기</h2>
<p>
    파이썬의 함수는 시작이나 끝을 지정하는 표시가 없습니다. 다른 언어처럼 괄호({ })도 사용하지 않습니다. 파이썬의 함수는 콜론(<code>:</code>)과 들여쓰기 만을 이용하여 그 시작과 끝을 나타냅니다.
<pre class=pp><code><a>def approximate_size(size, a_kilobyte_is_1024_bytes=True):  <span class=u>&#x2460;</span></a>
<a>    if size &lt; 0:                                            <span class=u>&#x2461;</span></a>
<a>        raise ValueError('number must be non-negative')     <span class=u>&#x2462;</span></a>
<a>                                                            <span class=u>&#x2463;</span></a>
    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
<a>    for suffix in SUFFIXES[multiple]:                       <span class=u>&#x2464;</span></a>
        size /= multiple
        if size &lt; multiple:
            return '{0:.1f} {1}'.format(size, suffix)

    raise ValueError('number too large')</code></pre>
<ol>
<li>
    코드 블록은 들여쓰기에 의해 결정됩니다. 여기서 코드 블록이라 함은, <code>if</code>문, <code>for</code>문, <code>while</code>문 등을 말하는 겁니다. 들여쓰기 시작하면 블록이 시작되고, 다시 내어쓰면 그 블록이 끝납니다. 대 소 괄호나, 키워드를 따로 써주지 않습니다. 이 말은 파이썬에선 빈칸이 특별한 의미를 가지기 때문에, 빈칸이 항상 일관적이어야 한다는 뜻입니다. 이 예제에서 함수 코드는 네칸을 띄워 썼습니다. 반드시 네칸일 필요는 없지만 한번 네칸으로 들어쓰기를 지정했다면 계속 네칸으로 사용해야 합니다. 함수 정의를 끝내기 위해서는 들여쓰기를 끝내면 됩니다.
<li>
    파이썬에서 <code>if</code> 구문 뒤에는 들여쓴 코드블럭이 따라옵니다. 만약 <code>if</code> 식에 대한 계산결과가 참이라면, 들여쓴 블록안에 있는 구문들이 실행되고, 만약 계산결과가 거짓이고 <code>else</code> 블럭이 존재한다면 else 블럭 안의 코드가 실행됩니다. if 문에 괄호를 사용하지 않은걸 눈여겨 보세요.
<li>
    이 줄은 <code>if</code> 코드 블럭 내부입니다. 만일 <code>size &lt; 0</code> 이 참으로 판명된다면, <code>raise</code> 구문이 <code>ValueError</code> 타입의 예외를 발생시킬 겁니다. 
<li>
    이 라인은 함수의 끝을 의미하는게 <em>아닙니다</em>. 코드를 좀 더 읽기 쉽게 하기 위해 한 라인을 비워두었을 뿐입니다. 파이썬은 완전히 빈 라인은 코드로 간주하지 않습니다. 함수는 다음 줄로 이어집니다.
<li>
    <code>for</code> 루프 역시 코드 블럭의 시작을 의미합니다. 같은 크기로 들여쓴다면 한 코드블럭에 여러 줄을 담더라도 문제 없습니다. 이 <code>for</code> 루프는 세 줄의 코드를 담고 있습니다. 코드 블럭에 여러 줄을 담았다 해서 특별히 사용해야 할 문법 같은건 없습니다. 그냥 계속 들여쓰고, 계속 이어나가면 됩니다.
</ol>

<p>
    처음엔 약간 어색하기도 하고 포트란을 써본 분들은 포트란과 헷갈리기도 하겠지만, 점점 익숙해지면 그 장점이 드러나기 시작할 겁니다. 파이썬에선 들여쓰기가 코딩 스타일이 아니라 강제적으로 따라야 하는 규칙이기때문에, 어느 누가 작성했건 간에 코드 생김새가 비슷 비슷 합니다. 이는 C++ 나 Java 같은 다른 언어에서 흔하게 겪는 코딩 스타일문제를 파이썬에선 겪지 않아도 됨을 의미합니다. if 문 다음에 대괄호(curly brace)를 같은 라인에 쓸건지 아님 다음 라인에 쓸건지 따위로 신경쓰지 않아도 된다는 거죠. 따라서 다른 파이썬 프로그래머의 코드라도 백이면 백, 코딩 스타일이 비슷할 수밖에 없는거고, 이는 곧 더 빨리 남의 모듈을 이해할 수 있다는 뜻이기도 합니다.   

<blockquote class='note compare java'>
<p><span class=u>&#x261E;</span>파이썬은 줄바꿈 문자(carriage return)를 사용해 구문을 나누고, 콜론과 들여쓰기를 이용해 코드 블럭을 구분합니다. 이에 반해 <abbr>C++</abbr>와 Java는 세미콜론을 사용해 문장을 나누고 대괄호(curly brace)를 써 코드 블럭을 나눕니다.
</blockquote>
<p class=a>&#x2042;









<h2 id=exceptions>예외</h2>

<p>
    파이썬 어디에나 예외가 있습니다. 사실상 파이썬 라이브러리의 모든 모듈이 예외처리를 합니다. 그리고 파이썬은 많은 경우에 예외를 일으킵니다. 이 책을 읽어나가면서도 많은 예외상황이 나타날 겁니다.

<p>
    예외가 뭘까요? 대부분의 경우 뭐가 잘못됐는지 표시하는 에러입니다. (모든 예외가 다 에러는 아니지만, 지금은 생각하지 않기로 하죠.) 어떤 프로그래밍 언어는 문제를 <em>확인하게끔</em> 에러 반환 코드를 지원합니다. 하지만 파이썬은 프로그램의 행동에 <em>영향을 미치는</em>, 예외상황을 만들어 낼 수 있습니다.

<p>
    파이썬 셸에서 에러가 발생하면, 셸은 상황에 대한 자세한 설명과 왜 문제가 생겼는지를 알려줍니다. 그러고는 멈추죠. 이런 상황을 <em>예상못한<font size=2>unhandled</font></em> 예외라 합니다. 문제가 생겼음을  알아채고 처리할수 있는 코드가 없는거죠. 그러면 프로그램은 다시 맨위로 올라와, 오류 고치는데 도움이 되는 정보를 주고는 멉춥니다. 셸에서라면 별 문제 될게 없지만, 어디선가 돌아가고 있는 파이썬 프로그램이 이런 일을 맞닥드렸을 때 예외상황을 처리할 코드가 없다면 모든 프로그램이 끼익! 하고 멈추게 됩니다. 그렇게 되길 원할수도 있지만 아닐수도 있죠. 

<blockquote class='note compare java'>
<p><span class=u>&#x261E;</span>파이썬 함수는 자바와 달리 어떤 예외를 발생시킬지 정의하지 않습니다. 어떤 예외상황이 있을지는 스스로 생각해내야 합니다.
</blockquote>

<p>
    예외상황이 언제나 프로그램의 충돌로 끝나지는 않습니다. 예외를 처리할 수도 있습니다. 가끔은 없는 변수에 값을 넣을 때처럼 진짜오류!가 있기도 하지만, 어떤 때는 예외가 일어날 것을 미리 알아챌수 있습니다. 없는 파일을 연다거나 불러오려는 모듈이 깔려 있지 않다거나 데이터베이스에 연결하려는데 그 데이터베이스가 없거나 제대로 된 보안키를 가지고 있지 않거나하는 상황 등, 코드의 어떤 부분에서 오류가 날지 알고 있다면 이런 예외를 처리하기 위해 <code>try...except</code> 구문을 써야합니다.

<blockquote class='note compare java'>
<p>
    <span class=u>&#x261E;</span>파이썬은 예외를 처리하기 위해 <code>try...except</code> 구문을 쓰고, 예외를 강제로 발생시키기 위해 <code>raise</code> 문을 씁니다. 자바와 <abbr>C++</abbr>은 예외를 처리하기 위해 <code>try...catch</code> 구문을 쓰고, 예외를 발생시키기 위해 <code>throw</code> 문을 씁니다.
</blockquote>

<p>
    여기서 <code>approximate_size()</code> 함수는 두가지 경우 예외를 발생시키는데 하나는 <var>size</var>가 처리할수 없을만큼 큰 값이 들어왔을때이고 다른 하나는 0보다 작은 값이 들어왔을 때입니다.

<pre class='nd pp'><code>if size &lt; 0:
    raise ValueError('number must be non-negative')</code></pre>

<p>
    예외 일으키기는 매우 간단합니다. <code>raise</code> 문 뒤에 예외이름을 쓰고 필요하다면 오류잡기에 도움되는 문장을 써넣으면 됩니다. 문법이 함수를 부를때와 비슷하죠? (실제로는 예외처리가 클래스로 구현되어 있고, 여기 <code>raise</code> 문은 <code>ValueError</code> 클래스의 인스턴스를 만들어 초기화 할 때 <code>'number must be non-negative'</code> 문자열을 넣어줍니다. 하지만 나중엔 직접 예외처리를 만들어 <a href=iterators.html#defining-classes>기본 예외처리를 덮어쓰도록</a> 해보죠!---더 쉽게,이해 어려움)

<blockquote class=note>
<p>
    <span class=u>&#x261E;</span>모든 함수에 예외처리를 만들지 않아도 됩니다. 어떤 함수가 예외를 처리하지 못한다면, 예외는 함수를 불러낸 함수로 올라갑니다. 그런식으로 단계를 거쳐 올라가죠. 그 와중에 예외가 처리되지 않는다면 프로그램은 충돌을 일으키고 파이썬이 오류 추적용 기본 메시지를 뱉고는 끝이 납니다. 다시 말하지만, 그렇게 하는것도 한 방법입니다. 어떤 프로그램이냐에 달렸죠.
</blockquote>

<h3 id=importerror>부르기 실패 알아채기</h3>

<p>
    파이썬은 모듈을 불러 오려다 실패했을 때 대비해 <code>ImportError</code> 예외를 미리 정의해 놓았습니다.  이 예외는 여러 이유에서 발생하는데, 보통은 불러오려는 모듈이 <a href=#importsearchpath>반입 검색 경로</a>에 없기 때문에 발생합니다. 이 예외를 써 프로그램에 기능을 추가할수 있습니다. 예로 프로그램이 문자 인코딩을 자동으로 찾아주는 <a href=case-study-porting-chardet-to-python-3.html> <code>chardet</code></a> 이라는 라이브러리를 불려오려다 설치되어있지않아 실패하더라도 <code>try..except</code> 구문을 사용해 우아하게 넘어갈 수 있습니다.

<pre class='nd pp'><code><mark>try</mark>:
  import chardet
<mark>except</mark> ImportError:
  chardet = None</code></pre>

<p>
    나중에 <code>if</code> 문으로 <code>chardet</code> 모듈이 있는지 간단히 체크해볼수 있습니다:

<pre class='nd pp'><code>if chardet:
  # do something
else:
  # continue anyway</code></pre>

<p>
    두개의 모듈이 다 일반적인 <abbr>API</abbr>로 이루어져 있지만, 하나가 다른 것보다 더 나을 때(아마 더 빠르거나, 메모리를 적게 먹겠죠.) 도 <code>ImportError</code>를 씁니다. 이 때 한 모듈을 불러오려다 실패하면 다른 모듈을 부릅니다. 예로 <a href=xml.html>XML 장</a>에서는 <code>ElementTree</code> <abbr>API</abbr>를 사용한 두 모듈에 대해 이야기 합니다. 그 중 <code>lxml</code> 모듈은 사용자가 직접 다운받아 깔아야 하는 부가모듈이고, <code>xml.etree.ElementTree</code>는 더 느리긴 하지만 파이썬3의 기본 라이브러리에 포함된 모듈입니다.

<pre class='nd pp'><code>try:
    from lxml import etree
except ImportError:
    import xml.etree.ElementTree as etree</code></pre>

<p>
    <code>try..except</code> 구문 마지막에 <em>아무개</em> 모듈을 불러와 <var>etree</var>라 부르기로 합니다. 두 모듈 다 일반 <abbr>API</abbr>를 썼기 때문에, 뒤쪽의 코드에서 어떤 모듈을 불러왔는지 알 필요가 없습니다. 그리고 불러온 모듈은 항상 <var>etree</var>라 부르기로 했기 때문에 나중에 <code>if</code> 문을 써 각각의 모듈 이름에 대한 경우의 수만큼 따로 정의할 필요가 없습니다.

<p class=a>&#x2042;

<h2 id=nameerror>고정되지 않는(좀더 나은표현?) 변수</h2>

<p><code>approximate_size()</code> 함수 선언의 다른부분을 살펴봅시다:

<pre class='nd pp'><code>multiple = 1024 if a_kilobyte_is_1024_bytes else 1000</code></pre>

<p><var>multiple</var>변수를 선언하지 않고 값을 집어 넣었습니다. 파이썬에서는 이렇게 하는것이 허용됩니다. 하지만 값이 들어가지 않은 변수를 참조하려는건 허용되지 않습니다. 이 때는 <code>NameError</code> 예외가 발생합니다.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'x' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>x = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=pp>1</samp></pre>

<p>언젠가 파이썬에게 고마워할겁니다.

<p class=a>&#x2042;

<h2 id=case>대소문자 구분은 확실히</h2>

<p>파이썬의 모든 이름은 다 대소문자를 구분합니다: 이름을 가지는 것에는 변수와 함수와 클래스와 모듈과 예외가 있습니다. 이들을 얻으려거나 지정하거나 부르거나 생성하거나 가져오거나 발생시킬 때는 대소문자를 구별해 써주세요.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>an_integer = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>an_integer</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd>AN_INTEGER</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'AN_INTEGER' is not defined</samp>
<samp class=p>>>> </samp><kbd>An_Integer</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'An_Integer' is not defined</samp>
<samp class=p>>>> </samp><kbd>an_inteGer</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
NameError: name 'an_inteGer' is not defined</samp>
</pre>

<p>이럴때는 항상 에러가 납니다.

<p class=a>&#x2042;

<h2 id=runningscripts>스크립트 실행하기</h2>
<aside>파이썬안의 모든것은 다 객체입니다.</aside>
<p>파이썬에서 모듈은 객체이고 몇가지 유용한 속성을 가집니다. 이를 이용하면만들고 있는 모듈을 간단히 테스트 해볼 수 있습니다.  커맨드 라인에서 파이썬 파일을 실행시킬때 특별한 구문을 추가하면 됩니다. <code>humansize.py</code>의 마지막 몇줄을 살펴보죠:
<pre class='nd pp'><code>
if __name__ == '__main__':
    print(approximate_size(1000000000000, False))
    print(approximate_size(1000000000000))</code></pre>
<blockquote class='note compare clang'>
<p><span class=u>&#x261E;</span><abbr>C</abbr>처럼 파이썬도 값을 비교할 때 <code>==</code>를 쓰고 값을 넣을때 <code>=</code>을 씁니다. 하지만 <abbr>C</abbr>와는 달리 비교하는 줄에서는 값을 집어넣을수 없습니다. 이렇게 하면 값을 비교하려다 넣어버리는 사고를 막을수 있죠.

</blockquote>
<p>자, 이 독특한 <code>if</code> 문은 뭘까요? 모듈은 객체죠, 그리고 모든 모듈은 <code>__name__</code>이란 고유속성을 가집니다. 모듈의 <code>__name__</code> 값은 모듈을 쓰는 방법에 따라 달라집니다. 만약 모듈을 <code>받아</code> 온거라면, <code>__name__</code> 은 이 모듈이 든 (디렉토리나 확장자를 제외한 순수한) 파일의 이름입니다.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<samp class=p>>>> </samp><kbd class=pp>humansize.__name__</kbd>
<samp class=pp>'humansize'</samp></pre>
<p>하지만 모듈을 직접 실행할수도 있겠죠. 그랬을 때 <code>__name__</code> 은 특별한 기본값 <code>__main__</code>이 됩니다. 파이썬이 이 <code>if</code> 문의 값을 계산해 식이 맞다는걸 확인하고, <code>if</code> 구문의 내용을 실행합니다. 그러면 두개의 값이 출력됩니다.
<pre class='nd screen'>
<samp class=p>c:\home\diveintopython3> </samp><kbd>c:\python31\python.exe humansize.py</kbd>
<samp>1.0 TB
931.3 GiB</samp></pre>
<p>자 이렇게 해서 우리의 첫 파이썬 프로그램을 다 둘러봤네요!
<p class=a>&#x2042;

<h2 id=furtherreading>더 읽을거리</h2>
<ul>
<li><a href=http://www.python.org/dev/peps/pep-0257/>PEP 257: Docstring Conventions</a> 무엇이 좋은 <code>참조문</code>과 위대한 <code>참조문</code>을 나누는지 설명합니다..
<li><a href=http://docs.python.org/3.1/tutorial/controlflow.html#documentation-strings>파이썬 튜토리얼: 참조 문자열</a> 또한 이 주제를 다룹니다.
<li><a href=http://www.python.org/dev/peps/pep-0008/>PEP 8: 파이썬 코드 스타일 가이드</a>는 좋은 들여쓰기 스타일에 대해 논의합니다.
<li><a href=http://docs.python.org/3.1/reference/><cite>파이썬 참고 매뉴얼</cite></a>은 <a href=http://docs.python.org/3.1/reference/datamodel.html#objects-values-and-types>파이썬의 모든것이 객체라 말할때</a> 그 의미가 무엇인지를 설명합니다. 현학적인 사람들은 이런 문제에 대해 장황하게 토론하기를 좋아하기 때문이죠.
</ul>
<p class=v><a rel=prev href=installing-python.html title='&#8220;파이썬 설치&#8221;로 돌아갑니다.'><span class=u>&#x261C;</span></a> <a rel=next href=native-datatypes.html title='&#8220;고유 자료형&#8221;으로 넘어갑니다.'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
