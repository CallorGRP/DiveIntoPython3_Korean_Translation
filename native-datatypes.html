<!DOCTYPE html>
<meta charset=utf-8>
<title>고유 자료형 - 파이썬 3로 뛰어들기</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 2}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Search></div></form>
<p>여기 있어요: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#native-datatypes>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>난이도: <span class=u title=beginner>&#x2666;&#x2666;&#x2662;&#x2662;&#x2662;</span>
<h1>고유 자료형</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span>

	모든 철학은 경이로움에서 태어나, 궁금증으로 성장하지만, 무관심으로 생을 마친다.<br>
<span class=u>&#x275E;</span><br>&mdash; Michel de Montaigne
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>뛰어들기</h2>
<p class=f>자료형입니다. <a href=your-first-python-program.html>우리의 첫번째 파이썬 프로그램</a>은 잠시 접어두고, 자료형에 대해서 이야기 해 봅시다. 파이썬의 <a href=your-first-python-program.html#declaringfunctions>모든 값은 그 타입을 갖고 있습니다</a>. 하지만 이를 명시적으로 선언할 필요는 없습니다. 어떻게 그게 가능할까요? 파이썬에서는 각 변수에 할당되는 값의 타입을 보고 변수의 데이터 타입을 유추하기 때문입니다. 그리고 내부적으로 이를 저장해놓기 때문에, 프로그래머가 명시적으로 변수의 타입을 선언해 줄 필요가 없습니다.
<p>파이썬은 다양한 자료형을 가지고 있습니다만, 우선 그 중 중요한 몇 가지만 살펴봅시다:
<ol>
<li><b><font size=2>Boolean</font></b> 은 <code>True</code> 또는 <code>False</code>입니다.
<li><b><font size=2>Numbers</font></b> 는 (<code>1</code>이나 <code>2</code> 같은) 정수일 수도 있고, (<code>1.1</code>이나 <code>1.2</code> 같은) 실수일 수도, (<code>1/2</code>이나 <code>2/3</code> 같은) 분수일 수도 있으며, 심지어 <a href=http://en.wikipedia.org/wiki/Complex_number>복소수</a>일 수도 있습니다.
<li><b><font size=2>String</font></b>은 유니코드 문자의 연속입니다, <i>일례로</i> <abbr>HTML</abbr> 문서는 String입니다.
<li><b><font size=2>Byte</font></b> 와 <b>byte array</b>, <i>일례로</i> <abbr>JPEG</abbr> 이미지 파일을 들 수 있습니다.
<li><b><font size=2>List</font></b> 는 어떤 값들을 순서대로 써놓은 것입니다.
<li><b><font size=2>Tuple</font></b> 은 내용을 변경할수 없는 (immutable) 한 값들을 순서대로 써놓은 것 입니다.
<li><b><font size=2>Set</font></b>은 어떤 값들을 순서에 상관없이 모아둔 것입니다.
<li><b>사전<font size=2>Dictionaries</font></b> 키-값 쌍의 모음들을 순서에 상관없이 모아둔 것입니다.
</ol>
<p>물론 이게 전부는 아닙니다. 파이썬에선 <a href=your-first-python-program.html#everythingisanobject>모든 것이 객체(Object) 입니다</a>. 따라서 모듈(module), 클래스(class), 메소드(method), 파일(file), 심지어 컴파일된 코드(compiled code)도 일종의 데이터 타입입니다. 이 중 몇 가지는 이미 앞에서 다뤘었죠? <a href=your-first-python-program.html#runningscripts>모듈은 __name__ 이라는 특성이 있고</a>, <a href=your-first-python-program.html#docstrings>함수엔 <code>docstrings</code>이라는 특성이 있습니다</a>. 클래스 타입은 <a href=iterators.html>클래스와 반복자</a> 챕터에서 자세히 다루도록 하고요, 파일 타입은 <a href=files.html>파일</a>챕터에서 다루겠습니다.
<p>문자열과 바이트는 매우 중요한데, 복잡하기도 해서 별도 챕터로 뺐습니다. 아무튼 이렇게 별도의 챕터로 빼둔 것들은 그때 다시 배우도록 하고요, 우선은 그를 제외한, 좀 쉬운 것부터 살펴보죠.<p class=a>&#x2042;

<h2 id=booleans>Booleans</h2>
<aside>You can use virtually any expression in a boolean context.</aside>


<p>
	Boolean은 참 이나 거짓 가운데 하나를 의미하는 데이터 타입입니다. 파이썬은 이를 위해 <code><dfn>True</dfn></code> 와 <code><dfn>False</dfn></code> 라는 상수를 정의해서 사용하고, 이 상수를 변수에 직접 할당하여 Boolean 타입으로 만들 수 있습니다. 어떤 상황에서는, 주어진 표현식이 반드시 <code><dfn>True</dfn></code> 이거나 <code><dfn>False</dfn></code> 여야 합니다. if 문을 예로 들 수 있습니다. if 문에 사용된 조건식은 반드시 <code><dfn>True</dfn></code> 나 <code><dfn>False</dfn></code> 가운데 하나로 판명나야 합니다. 이런 상황을 Boolean context 라고 부릅니다. Boolean context 에는 어떤 파이썬 표현식도 사용할 수 있습니다. 파이썬이 알아서 <code><dfn>True</dfn></code>나 <code><dfn>False</dfn></code> 중 하나로 평가해 주거든요. 하지만, 자료형마다 서로 다른 룰을 가지고, 참과 거짓이 판명된다는 사실은 알고 계셔야 합니다. 아리송하죠? 역시 예제를 보는 편이 낫겠네요.


<p>
	<a href=your-first-python-program.html#divingin><code>humansize.py</code> 에서 가져온 코드를 봅시다</a>:

<pre class='nd pp'><code>if size &lt; 0:
    raise ValueError('number must be non-negative')</code></pre>
<p>
	<var>size</var>는 정수, 0도 정수 입니다. <code>&lt;</code> 는 수 연산자이고요. 그래서, <code>size &lt; 0</code> 라는 파이썬 표현식은 언제나 참 또는 거짓입니다. 파이썬 쉘에서 테스트 해보세요.


<pre class='nd screen'>		
<samp class=p>>>> </samp><kbd class=pp>size = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>size = 0</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>size = -1</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>True</samp></pre>

<p>
	파이썬 버전 2에서와 같이, Boolean 타입을 숫자처럼 쓸 수도 있습니다. <code>True</code>는 <code>1</code>, <code>False</code>는 0을 의미합니다.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>True + True</kbd>
<samp class=pp>2</samp>
<samp class=p>>>> </samp><kbd class=pp>True - False</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>True * False</kbd>
<samp class=pp>0</samp>
<samp class=p>>>> </samp><kbd class=pp>True / False</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
ZeroDivisionError: int division or modulo by zero</samp></pre>

<p>
	아차. 제가 깜빡하고 말씀을 안드렸네요. 0으로 나누면 안되는거 아시죠?.

<p class=a>&#x2042;

<h2 id=numbers>Numbers</h2>

<p>
	이번 챕터에서는 다뤄야 할 것들이 굉장히 많습니다. 일단 파이썬 3는 <dfn>정수형(integer)</dfn>과 <dfn>실수형(floating point number)</dfn>을 지원합니다. 앞에서 말씀드렸듯이, 파이썬은 변수 선언시 타입을 별도로 선언하지 않기 때문에, 정수형인지 실수형인지를 판단하려면 값에 <dfn>소숫점</dfn>이 있는지 없는지를 봐야합니다.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>type(1)</kbd>                 <span class=u>&#x2460;</span></a>
<samp class=pp>&lt;class 'int'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>isinstance(1, int)</kbd>      <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1 + 1</kbd>                   <span class=u>&#x2462;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1 + 1.0</kbd>                 <span class=u>&#x2463;</span></a>
<samp class=pp>2.0</samp>
<samp class=p>>>> </samp><kbd class=pp>type(2.0)</kbd>
<samp class=pp>&lt;class 'float'></samp></pre>

<ol>
<li>
	어떤 값이나 변수의 타입을 확인하려면 <code>type()</code> 함수를 사용합니다. 당연히 <code>1</code> 은 <code>정수형</code>입니다.
<li>
	<code>isinstance()</code> 함수를 사용하면, 첫번째 파라미터로 넘겨진 값이나 변수가 두번째 파라미터로 넘겨진 타입과 같은지 아닌지를 알 수 있습니다.
<li>
	<code>정수</code>에 <code>정수</code>를 더하면 <code>정수</code>입니다.
<li>
	<code>정수</code>에 <code>실수</code>를 더하면 <code>실수</code>입니다. 파이썬에선 <code>정수</code>와 <code>실수</code>를 더하면, 먼저 정수를 <code>실수</code>로 변경한 후 연산을 적용합니다. 따라서 연산결과는 실수입니다.
</ol>


<h3 id=number-coercion>정수와 실수간 변환하기</h3>


<p>
	앞에서 본 것과 같이, 더하기 연산자 같은 연산자 들은 주어진 정수값을 그때 그때 상황에 맞게 먼저 실수값으로 변경후 연산에 적용합니다. 하지만 다음과 같이 명시적으로 타입을 변경할 수도 있습니다.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>float(2)</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>2.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(2.0)</kbd>                <span class=u>&#x2461;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(2.5)</kbd>                <span class=u>&#x2462;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(-2.5)</kbd>               <span class=u>&#x2463;</span></a>
<samp class=pp>-2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1.12345678901234567890</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>1.1234567890123457</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(1000000000000000)</kbd>  <span class=u>&#x2465;</span></a>
<samp class=pp>&lt;class 'int'></samp></pre>
<ol>

<li>
	<code>float()</code> 함수를 사용해 <code>int</code>형을 <code>float</code>형으로 강제 형 변환할 수 있습니다.

<li>
	<code>int()</code> 함수를 사용해 <code>float</code>형을 <code>int</code>형으로 바꿀 수 있습니다.

<li>
	<code>int()</code> 함수는 양수의 경우 소수점 아래는 그냥 버립니다.

<li>
	<code>int()</code> 함수는 음수의 경우도 소수점 아래는 버립니다. 

<li>
	실수는 소숫점 아래 15 자리까지만 표현할 수 있습니다.

<li>
	정수는 임의의 큰 수를 표현하는데 사용합니다.

</ol>
<blockquote class='note compare python2'>
<p><span class=u>&#x261E;</span>
파이썬 2에서는 int 형과 long 형을 따로 정의해 두었습니다. int 형의 크기는 sys.maxint 에 정의되어 있고요. 물론 윈도우인지 리눅스인지, 32비트인지 64비트인지 같은 OS 플랫폼에 따라 달라지긴 하지만, int 형의 크기는 최소한 <code>2<sup>32</sup>-1</code> 입니다. 파이썬 3에서는 long 형을 따로 두지 않고, 모든 정수는 int 형 하나로 표시합니다. 자세한 내용은 <a href=http://www.python.org/dev/peps/pep-0237><abbr>PEP</abbr> 237</a> 를 읽어 보세요.

</blockquote>
<h3 id=common-numerical-operations>파이썬으로 산술 연산 하기</h3>

<p>
	숫자를 가지고 할 수 있는 모든 일은 역시 파이썬으로도 할 수 있답니다.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>11 / 2</kbd>      <span class=u>&#x2460;</span></a>
<samp class=pp>5.5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 // 2</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>&minus;11 // 2</kbd>    <span class=u>&#x2462;</span></a>
<samp class=pp>&minus;6</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11.0 // 2</kbd>   <span class=u>&#x2463;</span></a>
<samp class=pp>5.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 ** 2</kbd>     <span class=u>&#x2464;</span></a>
<samp class=pp>121</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 % 2</kbd>      <span class=u>&#x2465;</span></a>
<samp class=pp>1</samp>
</pre>

<ol>

<li>
	<code>/</code> 연산자는 실수 나눗셈을 합니다. 분모와 분자 모두 <code>int</code>형이더라도 결과는 항상 <code>float</code> 형이 됩니다.


<li>
	<code>//</code> 연산자는 조금 독특한 정수 나눗셈을 합니다. 만약 결과가 양수라면 소숫점 이하는 무조건 버립니다. 하지만, 조심할게 있습니다.


<li>


	만약 <code>//</code> 연산자를 음수에 적용하면, 소숫점 이하는 역시 버리고, 결과를 가장 가까이 있는 자기보다 적은 정수값으로 만듭니다. 결과만 놓고 볼 때는, <code>&minus;5</code> 보다 <code>&minus;6</code>이 더 작으니까, 수학적으로 말하면 반내림과 같습니다. -5 라고 자신있게 말씀하셨던 분 많죠? 앞에서 조심하라고 말씀드렸었죠?


<li>
	<code>//</code> 연산자의 결과값이 언제나 정수형인 것은 아닙니다. 분자와 분모 중 하나가 실수형이면, 결과값도 실수입니다. 하지만 실수인 결과값 역시 가장 가까운 작은 정수로 변환됩니다.


<li>
	<code>**</code> 연산자는 제곱을 의미합니다. <code>11<sup>2</sup></code>은 <code>121</code>이죠.


<li>
	<code>%</code> 연산자는 정수 나눗셈을 하고 난 나머지를 돌려줍니다. <code>11</code>을 <code>2</code>로 나눈 나머지는 <code>1</code>이죠. 그래서 결과는 <code>1</code>입니다.

</ol>














<blockquote class='note compare python2'>
<p>
	<span class=u>&#x261E;</span>

	파이썬2 에서의 <code>/</code> 연산자는 정수 나눗셈을 의미했습니다만, 코드 안에 특별 지시자를 넣어 실수 나눗셈 또한 가능하도록 할 수 있었습니다. 그러나 파이썬3 에서는 <code>/</code> 연산자는 디폴트로 실수 나눗셈을 의미합니다. 더 자세한 내용은 <a href=http://www.python.org/dev/peps/pep-0238/><abbr>PEP</abbr> 238</a>을 참고하세요.

</blockquote>

<h3 id=fractions>분수(Fraction) 다루기</h3>
<p>

	파이썬이 정수나 실수 연산만 할 수 있는건 아닙니다. 여러분이 중고등학교 때 배웠던, 수학의 정석에나 나올 법한 복잡한 수학공식들도 파이썬은 척척 해낼 수 있습니다. 


<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import fractions</kbd>              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>x = fractions.Fraction(1, 3)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=pp>Fraction(1, 3)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>x * 2</kbd>                         <span class=u>&#x2462;</span></a>
<samp class=pp>Fraction(2, 3)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>fractions.Fraction(6, 4)</kbd>      <span class=u>&#x2463;</span></a>
<samp class=pp>Fraction(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>fractions.Fraction(0, 0)</kbd>      <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "fractions.py", line 96, in __new__
    raise ZeroDivisionError('Fraction(%s, 0)' % numerator)
ZeroDivisionError: Fraction(0, 0)</samp></pre>

<ol>

<li>
	분수를 사용하려면 먼저 <code>fractions</code> 모듈을 임포트해야 합니다.
<li>
	분수를 만드려면 <code>Fraction</code> 객체를 만들고, 파라미터로 분자와 분모를 넘겨줍니다.
<li>
	파이썬은 어떤 분수 계산도 할 수 있습니다. 결과값으로는 언제나 새로운 <code>Fraction</code> 객체가 반환됩니다. <code>2 * (1/3) = (2/3)</code>입니다.
<li>
	<code>Fraction</code> 객체는 분자와 분모를 감지해서 자동으로 크기를 맞춰줍니다. <code>(6/4) = (3/2)</code> 입니다.
<li>
	파이썬도 분모가 0이 되면 안된다는 것 쯤은 알고 있습니다.
</ol>


<h3 id=trig>삼각함수(Trigonometry) 다루기</h3>
<p>
	You can also do basic trigonometry in Python.
	기본적인 삼각함수도 사용할 수 있습니다.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>math.pi</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>3.1415926535897931</samp>
<a><samp class=p>>>> </samp><kbd class=pp>math.sin(math.pi / 2)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>1.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>math.tan(math.pi / 4)</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>0.99999999999999989</samp></pre>
<ol>

<li>
	
	<code>math</code> 모듈은 원주율을 의미하는 &pi 상수를 정의하고 있습니다. 

<li>

	math 모듈은 <code>sin()</code>, <code>cos()</code>, <code>tan()</code> 같은 기본 삼각함수들 뿐만 아니라, <code>asin()</code>같이 고급 삼각 함수도 지원합니다. 
<li>
	
	 <code>tan(&pi; / 4)</code>는 <code>1.0</code>을 반환합니다. <code>0.99999999999999989</code>가 아닙니다. 파이썬이 무한정밀도(infinite precision)을 지원하는 것은 아니거든요.

</ol>

<h3 id=numbers-in-a-boolean-context>숫자도 참 또는 거짓이 될 수 있습니다</h3>


<aside>
	0은 false 이고, 0이 아닌 숫자는 true입니다.
</aside>

<p>
	<code>if</code> 절 같은 곳에서는 <a href=#booleans>숫자를 참/거짓을 판별할 때 사용</a>할 수 있습니다. 0은 false로 0이 아닌 숫자는 true 로 판별됩니다.

	

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>             <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(1)</kbd>                         <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(-1)</kbd>
<samp>yes, it's true</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(0)</kbd>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(0.1)</kbd>                       <span class=u>&#x2462;</span></a>
<samp>yes, it's true</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(0.0)</kbd>
<samp>no, it's false</samp>
<samp class=p>>>> </samp><kbd class=pp>import fractions</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(fractions.Fraction(1, 2))</kbd>  <span class=u>&#x2463;</span></a>
<samp>yes, it's true</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(fractions.Fraction(0, 1))</kbd>
<samp>no, it's false</samp></pre>
<ol>

<li>

	파이썬 쉘 안에서도 함수를 정의할 수 있답니다. 함수를 작성해 나갈때는 엔터키를 이용해 다음 행으로 계속할 수 있고, 함수 정의가 끝났을때는 엔터키를 두번 사용해 공백 라인이 맨 마지막에 오도록 하면 됩니다. 
<li>

	boolean 값이 와야 하는 자리에 숫자가 사용되면 true 나 false 로 판명됩니다. 

<li>
	실수값도 마찬가지로 0이 아니면 <code>True</code> 입니다. <code>0.0</code>만 <code>False</code> 입니다. 반올림 등의 연산을 실수에 적용할 때는 조심하세요. <code>0.0000000000001</code> 같은 값도 0이 아니기 때문에 <code>True</code>로 판명됩니다.
<li>
	분수도 역시 0이 아니면 <code>True</code> 입니다. <code>Fraction(0, n)</code>의 경우 n에 어떤 값을 넣더라도 <code>False</code> 입니다. 이를 제외한 나머지는 모두 <code>True</code>입니다

</ol>
<p class=a>&#x2042;

<h2 id=lists>리스트</h2>

<p>

	리스트 (List) 데이터 타입은 파이썬에서 없어서는 안 될 충실한 심복중 하나입니다. 리스트라는 단어를 듣는 순간, 이렇게 생각하실지도 모르겠습니다. "음, 먼저 사이즈를 정해서 미리 선언해주고, 같은 데이터 타입만 집어 넣을 수 있겠군". 파이썬의 리스트 데이터 타입을 다른 프로그래밍 언어의 배열과 비슷할 거라고 생각하셨다면, 틀렸습니다. 파이썬 리스트는 그것보다 훨씬 멋지거든요. 

<blockquote class='note compare perl5'>

<p>
	<span class=u>&#x261E;</span>
	펄과 비교하면, 리스트는 펄 5의 배열과 유사합니다. 한편, 펄에서는 배열의 변수명이 항상 <code>@</code>로 시작해야 하지만, 파이썬엔 그런 제약이 없습니다. 파이썬은 내부적으로 데이터 형을 관리하기 때문에 명시적으로 나타낼 필요가 없는거죠.

</blockquote>

<blockquote class='note compare java'>
<p>
	파이썬 리스트는 다른 언어, 가령, 자바의 배열보다 훨씬 강력합니다. 물론 딱 배열처럼만 사용하려면 그렇게 사용할 수도 있습니다. 하지만, 어떤 타입의 객체도 담을 수 있고, 그 크기가 동적으로 늘어날 수 있다는 점에서는 자바의 <code>ArrayList</code> 클래스에 비유할 수 있겠네요.


</blockquote>

<h3 id=creatinglists>리스트 생성하기</h3>

<p>
	파이썬 리스트를 만드는 방법은 간단합니다. 꺽쇠 안에 값을 적어주고, 콤마로 구분하면 됩니다.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'mpilgrim', 'z', 'example']</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[0]</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[4]</kbd>                                        <span class=u>&#x2462;</span></a>
<samp class=pp>'example'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>                                       <span class=u>&#x2463;</span></a>
<samp class=pp>'example'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[-3]</kbd>                                       <span class=u>&#x2464;</span></a>
<samp class=pp>'mpilgrim'</samp></pre>
<ol>

<li>
	다섯개의 원소를 가진 리스트를 정의했습니다. 출력 결과에 주목하세요. 순서가 변하지 않고 그대로입니다.

<li>
	리스트는 배열처럼 사용할 수 있다고 앞에서 말씀드렸죠? <code>a_list[0]</code> 은 alist 라는 리스트의 첫번째 원소를 가져옵니다. 

<li>
	맨 마지막 아이템인 5번째 아이템은 <code>a_list[4]</code> 로 가져옵니다. 
<li>
	인덱스에 음수값을 주면 뒤에서부터 카운트 해온 값을 반환합니다. <code>a_list[-1]</code> 는 뒤에서 첫번째 아이템, 그러니까 맨 마지막 아이템을 반환합니다.
<li>
	혹시 음수값을 사용한 예가 잘 이해가 안되시는 분들은 이런 식으로 한번 생각해보세요. <code>a_list[-<var>n</var>] == a_list[len(a_list) - <var>n</var>]</code>. 그러니까 이 예제에서는 이렇게 됩니다. <code>a_list[-3] == a_list[5 - 3] == a_list[2]</code>.

</ol>

<h3 id=slicinglists>리스트 쪼개기</h3>
<aside>
	a_list[0]는 a_list의 첫번째 아이템입니다.
</aside>

<p>
	정의된 리스트에 대해 그 일부분을 떼내어 새로운 리스트로 정의할 수 있습니다. 이를 리스트 쪼개기 (list slicing)라고 합니다.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1:3]</kbd>            <span class=u>&#x2460;</span></a>
<samp class=pp>['b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1:-1]</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>['b', 'mpilgrim', 'z']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[0:3]</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[:3]</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[3:]</kbd>             <span class=u>&#x2464;</span></a>
<samp class=pp>['z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[:]</kbd>              <span class=u>&#x2465;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp></pre>
<ol>

<li>
	리스트를 쪼갤 때는 인덱스 두개와 그 사이에 콜론을 적어줍니다. 결과로 첫번째 인덱스 아이템(예에서는 <code>a_list[1]</code>) 을 포함하고, 두번째 인덱스의 바로 앞 아이템까지(예에서는 <code>a_list[3]</code>)를 포함하는 리스트를 반환합니다.   

<li>
	리스트를 쪼갤때 인덱스로 음수값을 줘도 됩니다. 헷갈리시면 이런 식으로 생각하셔도 됩니다. 첫 번째 인덱스는 포함시키고 싶은 파트의 첫 번째 위치입니다. 두 번째 인덱스는 포함시키고 싶지 않은 파트의 첫 번째 위치이고요. 그리고 이 둘 사이의 아이템을 취한 것이 결과입니다. 
<li>
	리스트의 인덱스는 0부터 시작합니다. 따라서 <code>a_list[0:3]</code>은 a_list 라는 리스트의 맨 처음부터 3개의 아이템입니다. <code>a_list[0]</code> 부터 시작하여 <code>a_list[3]</code>의 바로 앞까지 입니다.
<li>
	시작 인덱스가 0인 경우엔 생략이 가능합니다. 따라서 <code>a_list[:3]</code> 는 <code>a_list[0:3]</code>와 같은 의미입니다.
<li>
	마찬가지 원리로 종료 인덱스가 리스트의 길이와 같은 경우엔 생략이 가능합니다. 따라서 <code>a_list[3:]</code> 는 <code>a_list[3:5]</code> 와 같은 의미입니다. <code>a_list</code>에는 다섯 개의 아이템이 있기 때문입니다. 리스트 쪼개기에서 아름다운 대칭의 미가 느껴지지 않나요? <code>a_list[:3]</code> 는 리스트의 앞부분 3개 아이템을 반환하고, <code>a_list[3:]</code>는 이를 제외한 뒷부분 전부의 아이템을 반환합니다. 따라서 이렇게 일반화할 수 있겠네요. <code>a_list[:<var>n</var>]</code> 는 언제나 앞쪽 n개의 아이템을 반환하고, <code>a_list[<var>n</var>:]</code>는 n번째 아이템부터 리스트 끝까지를 반환합니다  

<li>
	만약 시작과 종료 인덱스 모두를 생략하면, 리스트 내 모든 아이템을 포함한다는 의미입니다. 원래 리스트랑 똑같은 복사본이 생기는 것입니다. 이를 이용하여, <code>a_list[:]</code> 라고 써주면 간단히 <code>a_list</code> 리스트를 복사할 수 있습니다. 
</ol>

<h3 id=extendinglists>리스트에 아이템 추가하기</h3>
<p>
	리스트에 아이템을 추가하는 방법들을 알아봅니다.


<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = a_list + [2.0, 3]</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=pp>['a', 2.0, 3]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.append(True)</kbd>           <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 2.0, 3, True]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.extend(['four', '&Omega;'])</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 2.0, 3, True, 'four', '&Omega;']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.insert(0, '&Omega;')</kbd>         <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['&Omega;', 'a', 2.0, 3, True, 'four', '&Omega;']</samp></pre>
<ol>

<li>
	<code>+</code> 연산자를 이용하여 리스트를 합칠 수 있고, 결과로는 새로운 리스트가 반환됩니다. 리스트에 담을 수 있는 아이템 갯수에는 제한이 없는데, 정확히 말하면 사용할 수 있는 메모리에 제한이 없다면 제약이 없는 셈입니다. 만약 구현하려는 어플리케이션의 사용 가능한 메모리가 많지 않다면, 사용시 주의해야 합니다. 이 코드가 하는 일을 두 단계로 나누면, 먼저 <var>a_list</var> 에 <var>[2.0, 3]</var>을 합치고, 그 결과를 다시 <var>a_list</var> 에 할당합니다. 다루고 있는 리스트의 크기가 크지 않다면 괜찮겠지만, 상당한 크기인 경우에는 두번째 단계인 할당이 일어나는 순간 많은 양의 메모리가 요구될 수 있습니다. 그 점을 미리 염두에 두셔야 합니다.


<li>
	리스트 내부에는 어떤 타입의 데이터도 함께 담을 수 있습니다. 꼭 같은 타입의 데이터일 필요는 없습니다. 이 예제는 string, 실수, 정수 이렇게 서로 다른 데이터 타입을 가진 리스트를 보여줍니다. 

<li>
	<code>append()</code> 메소드를 이용해 리스트의 맨 끝에 아이템을 추가할 수 있습니다. 이제 4개의 서로 다른 데이터 타입이 리스트 안에서 공존하는군요. 

<li>
	리스트는 파이썬 내부에선 클래스로 구현되있습니다. 따라서 리스트를 하나 만든다는 것은 리스트 클래스의 인스턴스를 하나 만든다는 것과 동일합니다. 모든 인스턴스에는 메소드가 있고, 리스트 또한 예외가 아닙니다. 이 예제 코드에서는 리스트 클래스의 <code>extend()</code> 메소드를 이용하여 기존 리스트에 아이템을 추가하고 있습니다. 메소드 인자가 추가할 데이터입니다. 


<li>
	<code>insert()</code> 메소드는 아이템 하나를 정해진 위치에 삽입할 때 사용합니다. 첫번째 인자는 삽입하고 싶은 위치이고, 동작이 성공적이면 뒤쪽에 위치한 아이템들은 자리가 하나씩 뒤로 밀리게 됩니다. 삽입하는 데이터가 기존 리스트에 이미 존재하더라고 상관없습니다. 리스트는 중복된 데이터도 허용하기 때문입니다. 예제 코드에서는 <code>'&Omega;'</code> 라는 값이 첫번째 인덱스와 마지막 인덱스, 이렇게 두 군데에서 보이고 있습니다.

</ol>

<blockquote class='note compare perl'>
<p>
	<span class=u>&#x261E;</span><code><var>a_list</var>.insert(0, <var>value</var>)</code>는 펄 함수 중 <code>unshift()</code> 함수와 비슷합니다. 리스트의 맨 앞에 아이템을 삽입하고 나머지 아이템들은 전부 뒤로 한 칸씩 이동시킵니다.


</blockquote>

<p>
	이번에는 <code>append()</code>와 <code>extend()</code>의 차이점에 대해 알아 봅시다.


<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'c']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.extend(['d', 'e', 'f'])</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'c', 'd', 'e', 'f']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_list)</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>6</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>
<samp class=pp>'f'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.append(['g', 'h', 'i'])</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'c', 'd', 'e', 'f', ['g', 'h', 'i']]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_list)</kbd>                     <span class=u>&#x2463;</span></a>
<samp class=pp>7</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>
<samp class=pp>['g', 'h', 'i']</samp></pre>
<ol>

<li>
	<code>extend()</code> 메소드는 리스트 타입의 인자를 받아서, 그 내부의 아이템들을 <var>a_list</var>안에 추가함으로써, 기존의 리스트를 그만큼 연장해(extend)줍니다.
<li>
	처음 3개의 아이템을 가진 리스트에 3개의 아이템이 있는 또 다른 리스트를 이용해 늘렸으므로, 이제 아이템의 갯수는 6개가 되었습니다. 
<li>
	한편 <code>append()</code> 메소드는 인자로 들어온 값을 리스트에 추가합니다. 인자는 하나이며, 인자의 타입은 어떤 타입이라도 괜찮습니다. 예제코드에서는 3 개의 아이템이 있는 리스트를 인자로 넘겨주고 있습니다.

<li>
	앞에서 리스트 내 아이템의 갯수가 6개 였으니까, 이제 9개가 되어야겠군요. 앗. 그런데, 파이썬 쉘은 7개라고 나오네요. 왜죠? 이게 바로 extend 메소드와 append 메소드 간의 차이점입니다. extend 메소드는 인자로 넘어온 리스트내 아이템 하나 하나를 추가해주지만, append 메소드는 인자가 리스트건 뭐건 상관없이 하나의 객체로 판단하고 이를 기존 리스트 끝에 추가합니다. 그래서 예제코드에선 ['g', 'h', 'i'] 가 3개의 개별적인 아이템이 아닌, 전체 리스트 하나가 통째로 리스트 안에 들어가게 된거죠. 리스트 객체는 다른 리스트 객체도 내부 아이템으로 가질 수 있다는 사실을 잊지마세요.

</ol>

<h3 id=searchinglists>
	Searching For Values In A List
	리스트 검색하기
</h3>
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'new', 'mpilgrim', 'new']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.count('new')</kbd>       <span class=u>&#x2460;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'new' in a_list</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>'c' in a_list</kbd>
<samp class=pp>False</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('mpilgrim')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('new')</kbd>       <span class=u>&#x2463;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('c')</kbd>         <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
ValueError: list.index(x): x not in list</samp></pre>
<ol>
<li>
	특정 값이 리스트 내에 몇 개나 있는지 그 횟수를 알고 싶을때는 <code>count()</code> 메소드를 사용하세요.
<li>
	그냥 어떤 값이 들어 있는지 아닌지만 알고 싶다면 <code>in</code> 연산자를 이용하는 편이 간단하고, 성능도 좀 더 빠릅니다. 결과로 <code>True</code> 나 <code>False</code>가 반환됩니다. 

<li>
	특정 값이 리스트내에서 몇 번째 있는지 알고 싶다면 <code>index()</code> 메소드를 사용하세요. 이 함수는 리스트 전체를 검색하여 해당 위치(0 부터 시작합니다) 를 반환합니다. 검색을 수행할 위치도 지정할 수 있는데요, 두번째 파라미터가 검색을 시작할 위치를 의미하고, 세번째 파라미터가 검색을 끝낼 위치를 의미합니다.   

<li>
	찾고자 하는 값이 리스트 내에 여러 번 등장하더라도, <code>index()</code> 메소드는 처음으로 발견한 위치를 반환합니다. 예에서 <code>'new'</code> 라는 문자열은 <code>a_list[2]</code> 에 하나, <code>a_list[4]</code>에 다른 하나, 이렇게 모두 두 번 등장합니다. 하지만, <code>index()</code> 메소드는 첫번째 위치인 2만 반환합니다. 

<li>
	검색대상이 발견되지 않으면, 예외를 일으킵니다.
</ol>

<p>
	잠깐만요. 뭔가 맘에 안듭니다. 보통 다른 언어같은 경우엔 검색하는 값이 없으면 <code>-1</code> 같은 값을 리턴해서 에러를 나타내잖아요? 파이썬도 그렇게 하면 안되나요? 예외까지 발생 시키는건 좀 오바 같은데요. 이렇게 생각하시는 분도 분명 계실겁니다. 하지만 한번 더 생각해보세요. 우리 프로그래머들은 대부분 게으릅니다. 만약 <code>-1</code>을 리턴받았는데, 에러값 조사도 꼼꼼히 하지 않고 그 위치에 있는 데이터를 읽으려고 하면 어떤 일이 생길까요? 아마 프로그램이 꽥 소리를 내며 죽을 수도 있습니다. 이런 코드는 잘 돌다가 꼭 금요일 밤에 비명횡사하기도 합니다. 금요일 밤 11시에 이런 코드를 디버깅하며 밤을 지새우기 보다, 차라리 언어레벨에서 예외를 던져주는 편이 훨씬 낫습니다. 물론, 예외 처리도 잘 해주지 않았다면 프로그램이 죽는건 마찬가지겠지만, 디버깅은 훨씬 더 쉬울겁니다. 예외를 맨 처음 던진 곳을 찾아가면 되니까요. 파이썬의 이런 디자인, 정말 멋지지 않나요? 



<h3 id=removingfromlists>리스트에서 아이템 삭제하기</h3>

<aside>리스트는 빈 공간을 허용하지 않습니다.</aside>

<p>리스트는 배열과 달리 아이템을 추가하면 그 크기가 동적으로 늘어나고, 삭제하면 동적으로 줄어듭니다. 

	앞에서는 리스트에 아이템을 추가해 리스트가 동적으로 확장시키는 방법을 알아봤으니, 이제부턴 리스트내 아이템을 삭제하는 방법을 알아봅시다. 아이템을 추가할 때와 마찬가지로 몇 가지 다른 방법을 사용할 수 있습니다.  
	Lists can expand and contract automatically. You&#8217;ve seen the expansion part. There are several different ways to remove items from a list as well.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'new', 'mpilgrim', 'new']</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_list[1]</kbd>
<samp class=pp>'b'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>del a_list[1]</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'new', 'mpilgrim', 'new']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1]</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>'new'</samp></pre>
<ol>
<li>
	del 구문을 이용하여 리스트 내 특정 아이템을 삭제할 수 있습니다.
<li>
	리스트에서 특정 위치의 아이템을 삭제했다고 해서, 그 자리가 마치 이빨빠진 자리처럼 계속 비워져 있지는 않습니다. 그 뒷부분에 위치한 아이템들이 자동으로, 차례대로 이동하여 빈자리를 메꿔줍니다. 따라서 여전히 그 자리는 다른 아이템에 의해 채워지게 됩니다. 

</ol>

<p>
	어떤 아이템을 지우고 싶은데 위치를 모른다고요? 문제 없습니다. 위치 인덱스 대신 삭제하고 싶은 값을 직접 입력하면 됩니다.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.remove('new')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'mpilgrim', 'new']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.remove('new')</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'mpilgrim']</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.remove('new')</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
ValueError: list.remove(x): x not in list</samp></pre>
<ol>

<li>
	<code>remove()</code> 메소드도 삭제에 사용하는 메소드 입니다. 삭제하고 싶은 아이템의 값을 파라미터로 받아 리스트내에서 첫번째로 발견되는 해당 아이템을 삭제합니다. 다시 한번 말씀드리지만, 특정 아이템이 삭제된 자리는 그 뒤의 아이템들이 자동으로 차례차례 메꿔줍니다.

<li>
	리스트 내 존재하지 않는 값을 삭제하려고 하면 예외가 발생됩니다.
</ol>

<h3 id=popgoestheweasel>리스트에서 아이템 삭제하기: 보너스</h3>

<p>
	Another interesting list method is <code>pop()</code>. The <code>pop()</code> method is yet another way to <a href=#removingfromlists>remove items from a list</a>, but with a twist.

	<code>pop()</code>이라는 메소드를 이용하여  <a href=#removingfromlists>리스트에서 아이템을 제거</a>할 수도 있습니다. 하지만, 주의할 점이 있습니다.


<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'new', 'mpilgrim']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>'mpilgrim'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'new']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop(1)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'b'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'new']</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>
<samp class=pp>'new'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>   <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
IndexError: pop from empty list</samp></pre>
<ol>
<li>
	<code>pop()</code> 메소드를 인자없이 호출하면 리스트의 맨 마지막 아이템을 반환하고, 해당 아이템은 삭제됩니다.
<li>
	<code>pop()</code> 메소드에 인자로 위치 인덱스를 주면, 해당 아이템을 반환후 삭제합니다.

<li>
	비어있는 리스트에 호출하면 예외가 발생됩니다.
</ol>

<blockquote class='note compare perl'>
<p>

	인자없는 <code>pop()</code> 메소드 호출은 펄의 <code>pop()</code> 함수와 유사합니다. 리스트 맨 마지막 원소를 반환하고, 리스트 내에서는 삭제합니다. 펄과 다른 점은, 리스트의 맨 앞부분 원소를 삭제할 때, 펄은 <code>shift()</code>라는 메소드를 따로 두고 있지만, 파이썬은 인자로 <code>0</code>을 주면 된다는 점입니다.

</blockquote>

<h3 id=lists-in-a-boolean-context>Lists In A Boolean Context리스트로 참, 거짓 판단하기</h3>
<aside>
	비어있는 리스트는 False 로 치환할 수 있고, 나머지는 True 입니다. 
</aside>
<p>
	You can also use a list in <a href=#booleans>a boolean context</a>, such as an <code>if</code> statement.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true([])</kbd>             <span class=u>&#x2460;</span></a>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(['a'])</kbd>          <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true([False])</kbd>        <span class=u>&#x2462;</span></a>
<samp>yes, it's true</samp></pre>
<ol>
<li>
	In a boolean context, an empty list is false.

<li>
	Any list with at least one item is true.

<li>
	Any list with at least one item is true. The value of the items is irrelevant.

</ol>

<p class=a>&#x2042;

<h2 id=tuples>Tuples</h2>

<p>A <dfn>tuple</dfn> is an immutable list.  A tuple can not be changed in any way once it is created.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple = ("a", "b", "mpilgrim", "z", "example")</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_tuple</kbd>
<samp class=pp>('a', 'b', 'mpilgrim', 'z', 'example')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[0]</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[-1]</kbd>                                       <span class=u>&#x2462;</span></a>
<samp class=pp>'example'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[1:3]</kbd>                                      <span class=u>&#x2463;</span></a>
<samp class=pp>('b', 'mpilgrim')</samp></pre>
<ol>
<li>
	A tuple is defined in the same way as a list, except that the whole set of elements is enclosed in parentheses instead of square brackets.
<li>
	The elements of a tuple have a defined order, just like a list. Tuple indices are zero-based, just like a list, so the first element of a non-empty tuple is always <code>a_tuple[0]</code>.
<li>
	Negative indices count from the end of the tuple, just like a list.
<li>
	Slicing works too, just like a list. When you slice a list, you get a new list; when you slice a tuple, you get a new tuple.
</ol>

<p>
	The major difference between tuples and lists is that tuples can not be changed. In technical terms, tuples are <dfn>immutable</dfn>. In practical terms, they have no methods that would allow you to change them. Lists have methods like <code>append()</code>, <code>extend()</code>, <code>insert()</code>, <code>remove()</code>, and <code>pop()</code>. Tuples have none of these methods. You can slice a tuple (because that creates a new tuple), and you can check whether a tuple contains a particular value (because that doesn&#8217;t change the tuple), and&hellip; that&#8217;s about it.

<pre class=screen>
# continued from the previous example
<samp class=p>>>> </samp><kbd class=pp>a_tuple</kbd>
<samp class=pp>('a', 'b', 'mpilgrim', 'z', 'example')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.append("new")</kbd>               <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'append'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.remove("z")</kbd>                 <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'remove'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.index("example")</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>4</samp>
<a><samp class=p>>>> </samp><kbd class=pp>"z" in a_tuple</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>
	You can&#8217;t add elements to a tuple. Tuples have no <code>append()</code> or <code>extend()</code> method.
<li>
	You can&#8217;t remove elements from a tuple. Tuples have no <code>remove()</code> or <code>pop()</code> method.
<li>
	You <em>can</em> find elements in a tuple, since this doesn&#8217;t change the tuple.
<li>
	You can also use the <code>in</code> operator to check if an element exists in the tuple.
</ol>

<p>
	So what are tuples good for?</p> 

<ul> 
<li>
	Tuples are faster than lists.  If you&#8217;re defining a constant set of values and all you&#8217;re ever going to do with it is iterate through it, use a tuple instead of a list.
<li>
	It makes your code safer if you &#8220;write-protect&#8221; data that doesn&#8217;t need to be changed. Using a tuple instead of a list is like having an implied <code>assert</code> statement that shows this data is constant, and that special thought (and a specific function) is required to override that.
<li>
	Some tuples can be used as dictionary keys (specifically, tuples that contain <i>immutable</i> values like strings, numbers, and other tuples). Lists can never be used as dictionary keys, because lists are not immutable.
</ul>

<blockquote class=note>
<p>
	<span class=u>&#x261E;</span>Tuples can be converted into lists, and vice-versa. The built-in <code>tuple()</code> function takes a list and returns a tuple with the same elements, and the <code>list()</code> function takes a tuple and returns a list. In effect, <code>tuple()</code> freezes a list, and <code>list()</code> thaws a tuple.
</blockquote>

<h3 id=tuples-in-a-boolean-context>Tuples In A Boolean Context</h3>

<p>
	You can use tuples in <a href=#booleans>a boolean context</a>, such as an <code>if</code> statement.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(())</kbd>             <span class=u>&#x2460;</span></a>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(('a', 'b'))</kbd>     <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true((False,))</kbd>       <span class=u>&#x2462;</span></a>
<samp>yes, it's true</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type((False))</kbd>              <span class=u>&#x2463;</span></a>
<samp class=pp>&lt;class 'bool'></samp>
<samp class=p>>>> </samp><kbd class=pp>type((False,))</kbd>
<samp class=pp>&lt;class 'tuple'></samp></pre>
<ol>
<li>
	In a boolean context, an empty tuple is false.
<li>
	Any tuple with at least one item is true.
<li>
	Any tuple with at least one item is true. The value of the items is irrelevant. But what&#8217;s that comma doing there?
<li>
	To create a tuple of one item, you need a comma after the value. Without the comma, Python just assumes you have an extra pair of parentheses, which is harmless, but it doesn&#8217;t create a tuple.
</ol>

<h3 id=multivar>Assigning Multiple Values At Once</h3>

<p>Here&#8217;s a cool programming shortcut: in Python, you can use a tuple to assign multiple values at once.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>v = ('a', 2, True)</kbd>
<a><samp class=p>>>> </samp><kbd>(x, y, z) = v</kbd>       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=pp>'a'</samp>
<samp class=p>>>> </samp><kbd class=pp>y</kbd>
<samp class=pp>2</samp>
<samp class=p>>>> </samp><kbd class=pp>z</kbd>
<samp class=pp>True</samp></pre>
<ol>
<li>
	<var>v</var> is a tuple of three elements, and <code>(x, y, z)</code> is a tuple of three variables. Assigning one to the other assigns each of the values of <var>v</var> to each of the variables, in order.
</ol>

<p>
	This has all kinds of uses. Suppose you want to assign names to a range of values. You can use the built-in <code>range()</code> function with multi-variable assignment to quickly assign consecutive values.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>MONDAY</kbd>                                                                       <span class=u>&#x2461;</span></a>
<samp class=pp>0</samp>
<samp class=p>>>> </samp><kbd class=pp>TUESDAY</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>SUNDAY</kbd>
<samp class=pp>6</samp></pre>
<ol>
<li>
	The built-in <code>range()</code> function constructs a sequence of integers. (Technically, the <code>range()</code> function returns an <a href=iterators.html>iterator</a>, not a list or a tuple, but you&#8217;ll learn about that distinction later.) <var>MONDAY</var>, <var>TUESDAY</var>, <var>WEDNESDAY</var>, <var>THURSDAY</var>, <var>FRIDAY</var>, <var>SATURDAY</var>, and <var>SUNDAY</var> are the variables you&#8217;re defining. (This example came from the <code>calendar</code> module, a fun little module that prints calendars, like the <abbr>UNIX</abbr> program <code>cal</code>. The <code>calendar</code> module defines integer constants for days of the week.)
<li>
	Now each variable has its value: <var>MONDAY</var> is 0, <var>TUESDAY</var> is <code>1</code>, and so forth.
</ol>

<p>
	You can also use multi-variable assignment to build functions that return multiple values, simply by returning a tuple of all the values. The caller can treat it as a single tuple, or it can assign the values to individual variables. Many standard Python libraries do this, including the <code>os</code> module, which you'll learn about in <a href=comprehensions.html#os>the next chapter</a>.

<p class=a>&#x2042;

<h2 id=sets>Sets</h2>

<p>
	A <dfn>set</dfn> is an unordered &#8220;bag&#8221; of unique values. A single set can contain values of any immutable datatype. Once you have two sets, you can do standard set operations like union, intersection, and set difference.

<h3 id=creating-a-set>Creating A Set</h3>

<p>
	First things first. Creating a set is easy.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = {1}</kbd>     <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(a_set)</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'set'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2}</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2}</samp></pre>
<ol>
<li>
	To create a set with one value, put the value in curly brackets (<code>{}</code>).
<li>
	Sets are actually implemented as <a href=iterators.html#defining-classes>classes</a>, but don&#8217;t worry about that for now.
<li>
	To create a set with multiple values, separate the values with commas and wrap it all up with curly brackets.
</ol>

<p>
	You can also create a set out of a <a href=#lists>list</a>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'mpilgrim', True, False, 42]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = set(a_list)</kbd>                           <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>                                         <span class=u>&#x2461;</span></a>
<samp class=pp>{'a', False, 'b', True, 'mpilgrim', 42}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                                        <span class=u>&#x2462;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim', True, False, 42]</samp></pre>


<ol>
<li>
	To create a set from a list, use the <code>set()</code> function. (Pedants who know about how sets are implemented will point out that this is not really calling a function, but instantiating a class. I <em>promise</em> you will learn the difference later in this book. For now, just know that <code>set()</code> acts like a function, and it returns a set.)
<li>
	As I mentioned earlier, a single set can contain values of any datatype. And, as I mentioned earlier, sets are <em>unordered</em>. This set does not remember the original order of the list that was used to create it. If you were to add items to this set, it would not remember the order in which you added them.
<li>
	The original list is unchanged.
</ol>

<p id=emptyset>Don&#8217;t have any values yet? Not a problem. You can create an empty set.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = set()</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>            <span class=u>&#x2461;</span></a>
<samp class=pp>set()</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(a_set)</kbd>      <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;class 'set'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>       <span class=u>&#x2463;</span></a>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>not_sure = {}</kbd>    <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>type(not_sure)</kbd>
<samp class=pp>&lt;class 'dict'></samp></pre>
<ol>

<li>
	To create an empty set, call <code>set()</code> with no arguments.
<li>
	The printed representation of an empty set looks a bit strange. Were you expecting <code>{}</code>, perhaps? That would denote an empty dictionary, not an empty set. You&#8217;ll learn about dictionaries later in this chapter.
<li>
	Despite the strange printed representation, this <em>is</em> a set&hellip;
<li>
	&hellip;and this set has no members.
<li>
	Due to historical quirks carried over from Python 2, you can not create an empty set with two curly brackets. This actually creates an empty dictionary, not an empty set.
</ol>

<h3 id=modifying-sets>Modifying A Set</h3>

<p>
	There are two different ways to add values to an existing set: the <code>add()</code> method, and the <code>update()</code> method.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(4)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 4}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>    <span class=u>&#x2461;</span></a>
<samp class=pp>3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(1)</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 4}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>    <span class=u>&#x2463;</span></a>
<samp class=pp>3</samp></pre>

<ol>
<li>
	The <code>add()</code> method takes a single argument, which can be any datatype, and adds the given value to the set.
<li>
	This set now has 3 members.
<li>
	Sets are bags of <em>unique values</em>. If you try to add a value that already exists in the set, it will do nothing. It won&#8217;t raise an error; it&#8217;s just a no-op.
<li>
	This set <em>still</em> has 3 members.
</ol>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2, 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update({2, 4, 6})</kbd>                       <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>                                         <span class=u>&#x2461;</span></a>
<samp class=pp>{1, 2, 3, 4, 6}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update({3, 6, 9}, {1, 2, 3, 5, 8, 13})</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3, 4, 5, 6, 8, 9, 13}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update([10, 20, 30])</kbd>                    <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3, 4, 5, 6, 8, 9, 10, 13, 20, 30}</samp></pre>
<ol>
<li>
	The <code>update()</code> method takes one argument, a set, and adds all its members to the original set. It&#8217;s as if you called the <code>add()</code> method with each member of the set.
<li>
	Duplicate values are ignored, since sets can not contain duplicates.
<li>
	You can actually call the <code>update()</code> method with any number of arguments. When called with two sets, the <code>update()</code> method adds all the members of each set to the original set (dropping duplicates).
<li>
	The <code>update()</code> method can take objects of a number of different datatypes, including lists. When called with a list, the <code>update()</code> method adds all the items of the list to the original set.
</ol>

<h3 id=removing-from-sets>Removing Items From A Set</h3>

<p>
	There are three ways to remove individual values from a set. The first two, <code>discard()</code> and <code>remove()</code>, have one subtle difference.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 10, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.discard(10)</kbd>                        <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.discard(10)</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.remove(21)</kbd>                         <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.remove(21)</kbd>                         <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 21</samp></pre>

<ol>
<li>
	The <code>discard()</code> method takes a single value as an argument and removes that value from the set.
<li>
	If you call the <code>discard()</code> method with a value that doesn&#8217;t exist in the set, it does nothing. No error; it&#8217;s just a no-op.
<li>
	The <code>remove()</code> method also takes a single value as an argument, and it also removes that value from the set.
<li>
	Here&#8217;s the difference: if the value doesn&#8217;t exist in the set, the <code>remove()</code> method raises a <code>KeyError</code> exception.
</ol>

<p>
	Like lists, sets have a <code>pop()</code> method.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>                                <span class=u>&#x2460;</span></a>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>
<samp class=pp>3</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>
<samp class=pp>36</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{6, 10, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.clear()</kbd>                              <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>set()</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>                                <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 'pop from an empty set'</samp></pre>

<ol>
<li>
	The <code>pop()</code> method removes a single value from a set and returns the value. However, since sets are unordered, there is no &#8220;last&#8221; value in a set, so there is no way to control which value gets removed. It is completely arbitrary.
<li>
	The <code>clear()</code> method removes <em>all</em> values from a set, leaving you with an empty set. This is equivalent to <code>a_set = set()</code>, which would create a new empty set and overwrite the previous value of the <var>a_set</var> variable.
<li>
	Attempting to pop a value from an empty set will raise a <code>KeyError</code> exception.
</ol>

<h3 id=common-set-operations>Common Set Operations</h3>

<p>
	Python&#8217;s <code>set</code> type supports several common set operations.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {2, 4, 5, 9, 12, 21, 30, 51, 76, 127, 195}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>30 in a_set</kbd>                                                     <span class=u>&#x2460;</span></a>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>31 in a_set</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>b_set = {1, 2, 3, 5, 6, 8, 9, 12, 15, 17, 18, 21}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.union(b_set)</kbd>                                              <span class=u>&#x2461;</span></a>
<samp class=pp>{1, 2, 195, 4, 5, 6, 8, 12, 76, 15, 17, 18, 3, 21, 30, 51, 9, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.intersection(b_set)</kbd>                                       <span class=u>&#x2462;</span></a>
<samp class=pp>{9, 2, 12, 5, 21}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.difference(b_set)</kbd>                                         <span class=u>&#x2463;</span></a>
<samp class=pp>{195, 4, 76, 51, 30, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.symmetric_difference(b_set)</kbd>                               <span class=u>&#x2464;</span></a>
<samp class=pp>{1, 3, 4, 6, 8, 76, 15, 17, 18, 195, 127, 30, 51}</samp></pre>

<ol>
<li>
	To test whether a value is a member of a set, use the <code>in</code> operator. This works the same as lists.
<li>
	The <code>union()</code> method returns a new set containing all the elements that are in <em>either</em> set.
<li>
	The <code>intersection()</code> method returns a new set containing all the elements that are in <em>both</em> sets.
<li>
	The <code>difference()</code> method returns a new set containing all the elements that are in <var>a_set</var> but not <var>b_set</var>.
<li>
	The <code>symmetric_difference()</code> method returns a new set containing all the elements that are in <em>exactly one</em> of the sets.
</ol>

<p>
	Three of these methods are symmetric.

<pre class=screen>
# continued from the previous example
<a><samp class=p>>>> </samp><kbd class=pp>b_set.symmetric_difference(a_set)</kbd>                                       <span class=u>&#x2460;</span></a>
<samp class=pp>{3, 1, 195, 4, 6, 8, 76, 15, 17, 18, 51, 30, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.symmetric_difference(a_set) == a_set.symmetric_difference(b_set)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.union(a_set) == a_set.union(b_set)</kbd>                                <span class=u>&#x2462;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.intersection(a_set) == a_set.intersection(b_set)</kbd>                  <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.difference(a_set) == a_set.difference(b_set)</kbd>                      <span class=u>&#x2464;</span></a>
<samp class=pp>False</samp></pre>

<ol>
<li>
	The symmetric difference of <var>a_set</var> from <var>b_set</var> <em>looks</em> different than the symmetric difference of <var>b_set</var> from <var>a_set</var>, but remember, sets are unordered. Any two sets that contain all the same values (with none left over) are considered equal.
<li>
	And that&#8217;s exactly what happens here. Don&#8217;t be fooled by the Python Shell&#8217;s printed representation of these sets. They contain the same values, so they are equal.
<li>
	The union of two sets is also symmetric.
<li>
	The intersection of two sets is also symmetric.
<li>
	The difference of two sets is not symmetric. That makes sense; it&#8217;s analogous to subtracting one number from another. The order of the operands matters.
</ol>

<p>
	Finally, there are a few questions you can ask of sets.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2, 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>b_set = {1, 2, 3, 4}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.issubset(b_set)</kbd>    <span class=u>&#x2460;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.issuperset(a_set)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(5)</kbd>             <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set.issubset(b_set)</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>b_set.issuperset(a_set)</kbd>
<samp class=pp>False</samp></pre>
<ol>
<li>
	<var>a_set</var> is a <dfn>subset</dfn> of <var>b_set</var>&nbsp;&mdash;&nbsp;all the members of <var>a_set</var> are also members of <var>b_set</var>.
<li>
	Asking the same question in reverse, <var>b_set</var> is a <dfn>superset</dfn> of <var>a_set</var>, because all the members of <var>a_set</var> are also members of <var>b_set</var>.
<li>
	As soon as you add a value to <var>a_set</var> that is not in <var>b_set</var>, both tests return <code>False</code>.
</ol>

<h3 id=sets-in-a-boolean-context>Sets In A Boolean Context</h3>

<p>
	You can use sets in <a href=#booleans>a boolean context</a>, such as an <code>if</code> statement.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(set())</kbd>          <span class=u>&#x2460;</span></a>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({'a'})</kbd>          <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({False})</kbd>        <span class=u>&#x2462;</span></a>
<samp>yes, it's true</samp></pre>
<ol>
<li>
	In a boolean context, an empty set is false.
<li>
	Any set with at least one item is true.
<li>
	Any set with at least one item is true. The value of the items is irrelevant.
</ol>

<p class=a>&#x2042;

<h2 id=dictionaries>Dictionaries</h2>

<p>
	A <dfn>dictionary</dfn> is an unordered set of key-value pairs. When you add a key to a dictionary, you must also add a value for that key. (You can always change the value later.) Python dictionaries are optimized for retrieving the value when you know the key, but not the other way around.
<blockquote class='note compare perl5'>
<p>
	<span class=u>&#x261E;</span>A dictionary in Python is like a hash in Perl 5. In Perl 5, variables that store hashes always start with a <code>%</code> character. In Python, variables can be named anything, and Python keeps track of the datatype internally.
</blockquote>
<h3 id=creating-dictionaries>Creating A Dictionary</h3>
<p>
	Creating a dictionary is easy. The syntax is similar to <a href=#sets>sets</a>, but instead of values, you have key-value pairs. Once you have a dictionary, you can look up values by their key.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict = {'server': 'db.diveintopython3.org', 'database': 'mysql'}</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'database': 'mysql'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['server']</kbd>                                                    <span class=u>&#x2461;</span></a>
'db.diveintopython3.org'
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['database']</kbd>                                                  <span class=u>&#x2462;</span></a>
'mysql'
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['db.diveintopython3.org']</kbd>                                    <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 'db.diveintopython3.org'</samp></pre>
<ol>
<li>
	First, you create a new dictionary with two items and assign it to the variable <var>a_dict</var>. Each item is a key-value pair, and the whole set of items is enclosed in curly braces.
<li>
	<code>'server'</code> is a key, and its associated value, referenced by <code>a_dict['server']</code>, is <code>'db.diveintopython3.org'</code>.
<li>
	<code>'database'</code> is a key, and its associated value, referenced by <code>a_dict['database']</code>, is <code>'mysql'</code>.
<li>
	You can get values by key, but you can&#8217;t get keys by value. So <code>a_dict['server']</code> is <code>'db.diveintopython3.org'</code>, but <code>a_dict['db.diveintopython3.org']</code> raises an exception, because <code>'db.diveintopython3.org'</code> is not a key.
</ol>

<h3 id=modifying-dictionaries>Modifying A Dictionary</h3>
<p>
	Dictionaries do not have any predefined size limit. You can add new key-value pairs to a dictionary at any time, or you can modify the value of an existing key. Continuing from the previous example:
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'database': 'mysql'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['database'] = 'blog'</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['user'] = 'mark'</kbd>      <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=pp>{'server': 'db.diveintopython3.org', 'user': 'mark', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['user'] = 'dora'</kbd>      <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'user': 'dora', 'database': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['User'] = 'mark'</kbd>      <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'User': 'mark', 'server': 'db.diveintopython3.org', 'user': 'dora', 'database': 'blog'}</samp></pre>

<ol>
<li>
	You can not have duplicate keys in a dictionary. Assigning a value to an existing key will wipe out the old value.
<li>
	You can add new key-value pairs at any time. This syntax is identical to modifying existing values.
<li>
	The new dictionary item (key <code>'user'</code>, value <code>'mark'</code>) appears to be in the middle. In fact, it was just a coincidence that the items appeared to be in order in the first example; it is just as much a coincidence that they appear to be out of order now.
<li>
	Assigning a value to an existing dictionary key simply replaces the old value with the new one.
<li>
	Will this change the value of the <code>user</code> key back to "mark"?  No!  Look at the key closely&nbsp;&mdash;&nbsp;that&#8217;s a capital <kbd>U</kbd> in <kbd>"User"</kbd>. Dictionary keys are case-sensitive, so this statement is creating a new key-value pair, not overwriting an existing one. It may look similar to you, but as far as Python is concerned, it&#8217;s completely different.
</ol>

<h3 id=mixed-value-dictionaries>Mixed-Value Dictionaries</h3>

<p>
	Dictionaries aren&#8217;t just for strings. Dictionary values can be any datatype, including integers, booleans, arbitrary objects, or even other dictionaries. And within a single dictionary, the values don&#8217;t all need to be the same type; you can mix and match as needed. Dictionary keys are more restricted, but they can be strings, integers, and a few other types. You can also mix and match key datatypes within a dictionary.
<p>
	In fact, you&#8217;ve already seen a dictionary with non-string keys and values, in <a href=your-first-python-program.html#divingin>your first Python program</a>.
<pre class='nd pp'><code>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}</code></pre>
<p>
	Let's tear that apart in the interactive shell.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],</kbd>
<samp class=p>... </samp><kbd class=pp>            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>len(SUFFIXES)</kbd>      <span class=u>&#x2460;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1000 in SUFFIXES</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1000]</kbd>     <span class=u>&#x2462;</span></a>
<samp class=pp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1024]</kbd>     <span class=u>&#x2463;</span></a>
<samp class=pp>['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1000][3]</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>'TB'</samp></pre>

<ol>
<li>
	Like <a href=#lists>lists</a> and <a href=#sets>sets</a>, the <code>len()</code> function gives you the number of keys in a dictionary.
<li>
	And like lists and sets, you can use the <code>in</code> operator to test whether a specific key is defined in a dictionary.
<li>
	<code>1000</code> <em>is</em> a key in the <code>SUFFIXES</code> dictionary; its value is a list of eight items (eight strings, to be precise).
<li>
	Similarly, <code>1024</code> is a key in the <code>SUFFIXES</code> dictionary; its value is also a list of eight items.
<li>
	Since <code>SUFFIXES[1000]</code> is a list, you can address individual items in the list by their 0-based index.
</ol>

<h3 id=dictionaries-in-a-boolean-context>Dictionaries In A Boolean Context</h3>
<aside>Empty dictionaries are false; all other dictionaries are true.</aside>
<p>
	You can also use a dictionary in <a href=#booleans>a boolean context</a>, such as an <code>if</code> statement.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({})</kbd>             <span class=u>&#x2460;</span></a>
<samp>no, it's false</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({'a': 1})</kbd>       <span class=u>&#x2461;</span></a>
<samp>yes, it's true</samp></pre>
<ol>
<li>
	In a boolean context, an empty dictionary is false.
<li>
	Any dictionary with at least one key-value pair is true.
</ol>
<p class=a>&#x2042;

<h2 id=none><code>None</code></h2>
<p>
	<code><dfn>None</dfn></code> is a special constant in Python. It is a <dfn>null</dfn> value. <code>None</code> is not the same as <code>False</code>. <code>None</code> is not 0. <code>None</code> is not an empty string. Comparing <code>None</code> to anything other than <code>None</code> will always return <code>False</code>.

<p>
	<code>None</code> is the only null value. It has its own datatype (<code>NoneType</code>). You can assign <code>None</code> to any variable, but you can not create other <code>NoneType</code> objects. All variables whose value is <code>None</code> are equal to each other.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>type(None)</kbd>
<samp class=pp>&lt;class 'NoneType'></samp>
<samp class=p>>>> </samp><kbd class=pp>None == False</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == ''</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == None</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>x = None</kbd>
<samp class=p>>>> </samp><kbd class=pp>x == None</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>y = None</kbd>
<samp class=p>>>> </samp><kbd class=pp>x == y</kbd>
<samp class=pp>True</samp>
</pre>
<h3 id=none-in-a-boolean-context><code>None</code> In A Boolean Context</h3>
<p>In <a href=#booleans>a boolean context</a>, <code>None</code> is false and <code>not None</code> is true.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(anything):</kbd>
<samp class=p>... </samp><kbd class=pp>  if anything:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("yes, it's true")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("no, it's false")</kbd>
<samp class=p>...</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(None)</kbd>
<samp>no, it's false</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(not None)</kbd>
<samp>yes, it's true</samp></pre>
<p class=a>&#x2042;

<h2 id=furtherreading>Further Reading</h2>
<ul>
<li>
	<a href=http://docs.python.org/3.1/library/stdtypes.html#boolean-operations-and-or-not>Boolean operations</a>
<li>
	<a href=http://docs.python.org/3.1/library/stdtypes.html#numeric-types-int-float-long-complex>Numeric types</a>
<li>
	<a href=http://docs.python.org/3.1/library/stdtypes.html#sequence-types-str-unicode-list-tuple-buffer-xrange>Sequence types</a>
<li>
	<a href=http://docs.python.org/3.1/library/stdtypes.html#set-types-set-frozenset>Set types</a>
<li>
	<a href=http://docs.python.org/3.1/library/stdtypes.html#mapping-types-dict>Mapping types</a>
<li>
	<a href=http://docs.python.org/3.1/library/fractions.html><code>fractions</code> module</a>
<li>
	<a href=http://docs.python.org/3.1/library/math.html><code>math</code> module</a>
<li>
	<a href=http://www.python.org/dev/peps/pep-0237/><abbr>PEP</abbr> 237: Unifying Long Integers and Integers</a>
<li>
	<a href=http://www.python.org/dev/peps/pep-0238/><abbr>PEP</abbr> 238: Changing the Division Operator</a>
</ul>

<p class=v><a href=your-first-python-program.html rel=prev title='back to &#8220;Your First Python Program&#8221;'><span class=u>&#x261C;</span></a> <a href=comprehensions.html rel=next title='onward to &#8220;Comprehensions&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
